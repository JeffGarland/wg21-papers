\newcommand\wgTitle{A minimal ADL restriction to avoid ill-formed template instantiation}
\newcommand\wgName{Matthias Kretz <m.kretz@gsi.de>}
\newcommand\wgDocumentNumber{DMADLR0}
\newcommand\wgGroup{EWG}
\newcommand\wgTarget{\CC{}26}
%\newcommand\wgAcknowledgements{ }

\usepackage{mymacros}
\usepackage{wg21}
\usepackage{changelog}
\usepackage{underscore}

\addbibresource{extra.bib}

\newcommand\wglink[1]{\href{https://wg21.link/#1}{#1}}
\newcommand\notyetinstantiated{not\hyp{}yet\hyp{}instantiated\hyp{}templates\xspace}

\begin{document}
\selectlanguage{american}
\begin{wgTitlepage}
  I researched and tested a minimal change to ADL to avoid ill-formed instantiations of 
  templates through ADL. This paper presents the idea and a call for examples which would 
  get broken.
\end{wgTitlepage}

\pagestyle{scrheadings}

%\input{changelog}

%\input{strawpolls}

\section{Introduction}

Consider the innocent-looking code in \lst{example1} (as posted to the core reflector by 
Jonathan Wakely\footnote{\url{http://lists.isocpp.org/core/2021/06/11161.php} (the basic 
idea of this paper was already hinted at in the resulting discussion thread)}).
\begin{lstlisting}[style=Vc,float,label=lst:example1,caption={
Ill-formed instantiation of \type{Wrap<Incomplete>} because of ADL
}]
struct Incomplete;
template <typename T> struct Wrap { T t; };

template <typename Unused>
struct Testable
{
  explicit operator bool() const { return true; }
};

int main()
{
  Testable<Incomplete> l;
  if (l) // OK
    return 1;
  if (!(bool)l) // OK
    return 0;
  if (!l) // OK
    return 0;

  Testable<Wrap<Incomplete>> l2;
  if (l2) // OK
    return 1;
  if (!(bool)l2) // OK
    return 0;
  if (!l2) // ERROR
    return 0;
}
\end{lstlisting}

The expression \code{!l2} leads to name lookup of \code{operator!}. The associated 
entities are \type{Testable<Wrap<Incomplete>>}, \type{Wrap<In\-com\-plete>}, and 
\type{Incomplete}.
In this example \type{Testable<Wrap<Incomplete>>} must already have been successfully 
instantiated, otherwise the declaration of \code{l2} would have been ill-formed.
The type \type{Incomplete} is incomplete and the failure to look for \code{operator!} 
inside \type{Incomplete} is ignored.
The type \type{Wrap<Incomplete>} is a template specialization which has not been 
instantiated at this point in the translation. But instead of treating the type like the 
incomplete \type{Incomplete} type, the compiler attempts to instantiate the 
specialization, which leads to an ill-formed definition of its data member since it has 
incomplete type.

The expression \code{!l} is well-formed since ADL ignores incomplete types. Consequently, 
a later definition of \type{Incomplete} as
\medskip\begin{lstlisting}[style=Vc]
struct Incomplete {
  friend bool operator!(Testable<Incomplete>) { return true; }
}
\end{lstlisting}
changes the value of the expression \code{!l}.

Why does the standard allow incomplete types (i.e. not require completion) as associated 
entities even though they can be used to violate the ODR? Isn't the same reasoning 
applicable to templates that have not be instantiated yet? And what are the use cases for 
defining a hidden friend in \type{Wrap<Incomplete>} which wins in overload resolution when 
the argument is a \type{Testable<Wrap<Incomplete>>}?

To complete the picture, note that the issue is not specific to operators (e.g. 
\lst{example2} as presented by \textcite{P2538R0}). However, for operators there's no 
simple “always fully qualify your calls” rule to avoid ADL.

\begin{lstlisting}[style=Vc,numbers=left,float,label=lst:example2,caption={
Minimal example triggering ill-formed instantiation
}]
template<class T> struct Holder { T t; };
struct Incomplete;
Holder<Incomplete> *p;
int f(Holder<Incomplete>*);
int x = f(p);    // error: Holder<Incomplete> is an associated entity
int y = ::f(p);  // ok: no ADL
\end{lstlisting}

\subsection{History}

To understand how much code might be affected by a breaking change in this area, it is 
helpful to know that template instantiation via ADL had not been implemented in compilers 
for a long time. Template instantiation vial ADL works since GCC 4.5.0 (April 2010), Clang 
3.1.0 (May 2012), and since an ICC release between ICC 14 and 16\footnote{I have only been 
  able to test with the compilers available on Compiler Explorer}.

\pagebreak

\section{Solution idea}

Let us consider a simple solution to make ADL avoid the above situations:\\
\emph{Don't instantiate templates via ADL} (with one or two exceptions).

\textsc{Rationale:} If a given associated entity has not been instantiated at this point 
in the translation,
\begin{enumerate}
\item the user might have avoided instantiation intentionally since instantiation would be 
ill-formed; and
\item the type was not important enough up to this point that instantiation was necessary 
--- the chances for it to make a semantic difference are small ---.
\end{enumerate}

If I interpret the current wording correctly, the reason compilers instantiate templates 
via ADL is [temp.inst] p2:
\begin{wgText}[{[temp.inst]}]

\setcounter{Paras}{1}
\pnum Unless a class template specialization is a declared specialization, the class 
template specialization is implicitly instantiated when the specialization is referenced 
in a context that requires a completely-defined object type or when the completeness of 
the class type affects the semantics of the program. [\ldots]

\end{wgText}
In basically all cases, the completeness of the class type does not affect the semantics 
of the program, though. But the compiler cannot know that instantiation is unnecessary 
until after it instantiated the template.


\subsection{Necessary instantiation}

The one case where instantiation via ADL is still required is shown in 
\lst{needsInstantiation}.
\begin{lstlisting}[style=Vc,numbers=left,float,label=lst:needsInstantiation,caption={
Requires instantiation or reasonable code could break.
}]
template <typename T>
struct A {
  friend void f(const A&);
};

void g(const A<int>& x) {
  f(x);
}
\end{lstlisting}
The situation in \lst{needsInstantiation} is unlikely, but certainly not 
impossible\footnote{\url{https://gcc.gnu.org/PR34870} lead to GCC instantiating templates 
via ADL}, since almost every other use of the lvalue \code{x} would lead to instantiation.

Therefore, given an argument of reference to \code{T}, ADL should instantiate \code{T} and 
its bases but none of its template arguments.

\subsection{Namespaces of base classes}

Consider \lst{baseNamespace} which defines a base class in a different namespace 
(\code{A}) than the derived class template.
\begin{lstlisting}[style=Vc,numbers=left,float,label=lst:baseNamespace,caption={
ADL in namespace of base class
}]
namespace A {
  class B {};
  void f(B*);
}
void f(void*);

template <class T> class C : public A::B {};

void g(C<int>* p) {
  f(p); // calls ::f
  A::B* other_ptr = p;
  f(p); // calls A::f
}

// analogue situation with incomplete types:
class I;
void g0(I* p) { f(p); } // calls ::f
class I : public A::B {};
void g1(I* p) { f(p); } // calls A::f
\end{lstlisting}
In order for ADL to consider \code{A} as associated namespace when an argument of type 
\code{C<int>*} is used, the base types of the class template need to be know. However, if 
ADL were not to instantiate \code{C<int>} anymore, the behavior would depend on the 
preceding code, whether \code{C<int>} had already been instantiated or not. The analogue 
issue for an incomplete type \code{I} exhibits the same behavior change in ADL after 
defining \code{I}. However, for the incomplete type it is more obvious why the base types' 
namespaces are not considered (“You didn't say that \code{A::B} is a base!”).

Note that overload resolution still has to instantiate class templates to find bases, as 
shown in \lst{instantiateOverloadResolution}.
\begin{lstlisting}[style=Vc,numbers=left,float,label=lst:instantiateOverloadResolution,caption={
Class template instantiation on overload resolution if ADL does not instantiate \code{C<int>}
}]
class B0 {};
namespace A {
  class B : public B0 {};
  void f(B*);
}
void f(void*);
void f(B0*);

template <class T> class C : public A::B {};

void g(C<int>* p) {
  f(p); // calls ::f(B0*)
        // candidates: ::f(void*) and ::f(B0*), overload resolution instantiates
        // C<int> and picks ::f(B0*), i.e. overload resolution works unchanged
  f(p); // calls A::f(A::B*)
        // because ADL now finds the additional candidate A::f(A::B*)
}
\end{lstlisting}
It is an open question whether template instantiation via ADL on arguments of pointer type 
is enough of a problem to warrant the surprising behavior of 
\lst{instantiateOverloadResolution} (vs. the surprising behavior of \lst{example2}). As a 
more conservative change to ADL, given an argument of pointer to \code{T}, let ADL 
instantiate \code{T} and its bases but none of its template arguments.

Beyond references and pointers --- as far as I have seen --- there is little use in ADL 
instantiating templates. I recommend to modify [basic.lookup.argdep] and/or [temp.inst] to 
treat \notyetinstantiated types like incomplete types except if the \notyetinstantiated 
type is the type of the function argument.

\section{Alternative solutions}

\subsection{Tentative instantiation}
It seems like an obvious solution to require IFINAE (instantiation failure is not an 
error) on ADL, i.e. to require tentative template instantiation. However, this would place 
a huge burden on implementations: The instantiation depth might be very deep, before the 
condition is found. IFINAE requires a rollback of all unfinished instantiations that lead 
to the issue. It seems like a solvable task for compilers, but without implementation 
experience it is not a realistic path forward.

\subsection{Inhibit instantiation if a template parameter is incomplete}

A minimal solution for solving the problem in \lst{example1} inhibits instantiation on ADL 
if a template parameter is incomplete. This would cover some of the cases where ADL 
appears too eager. However, only minor variations of such examples would instantiate the 
class templates again, leading to the same errors we were trying to fix. The solution 
would thus appear to be rather fragile and potentially more confusing than helpful.

\section{Implementation Experience}
I implemented the presented idea for GCC and found no code breakage up to now.

\section{Suggested Straw Polls}
\wgPoll{Ship it!}{&&&&}

\end{document}
% vim: sw=2 sts=2 ai et tw=90 formatoptions=trowan2
