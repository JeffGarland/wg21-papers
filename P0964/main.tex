\newcommand\wgTitle{Finding the right set of traits for \code{simd<T>}}
\newcommand\wgName{Matthias Kretz <m.kretz@gsi.de>}
\newcommand\wgDocumentNumber{D0964R1}
\newcommand\wgGroup{SG1, LEWG}
%\newcommand\wgTarget{Parallelism TS 2}
%\newcommand\wgAcknowledgements{ }

\usepackage{mymacros}
\usepackage{wg21}
\usepackage{underscore}

\addbibresource{extra.bib}

\newcommand\simd[1][]{\type{simd#1}\xspace}
\newcommand\simdT{\type{simd<T>}\xspace}
\newcommand\valuetype{\type{value\_type}\xspace}
\newcommand\referencetype{\type{reference}\xspace}
\newcommand\whereexpression{\type{where\_expression}\xspace}
\newcommand\simdcast{\code{simd\_cast}\xspace}
\newcommand\mask[1][]{\type{simd\_mask#1}\xspace}
\newcommand\maskT{\type{simd\_mask<T>}\xspace}
\newcommand\fixedsizeN{\type{simd\_abi::fixed\_size<N>}\xspace}
\newcommand\fixedsizescoped{\type{simd\_abi::fixed\_size}\xspace}
\newcommand\fixedsize{\type{fixed\_size}\xspace}
\newcommand\simdEP{\code{execution::}\type{simd}\xspace}
\newcommand\seqEP{\code{execution::}\type{seq}\xspace}
\newcommand\realArithmeticType{vectorizable type\xspace}

\usepackage{pifont}

\newcommand\foralli[1][]{for all \code i $\in$ \code{[0, #1size())}\xspace}
\newcommand\forallmaskedi[1]{%
  for all \code i
  $\in \{j \in \mathbb{N}_0 | j < \code{size()} ⋀ \code{#1[}j\code{]}\}$%
  \xspace%
}
\newcommand\chck{\item[\color{black}\ensuremath{\checkmark}]}
\newcommand\todo{\item[\color{black}\ding{46}] \color{gray}}
\newcommand\itemheader[1]{\item[] \hfill \textcolor{gray}{\textsc{#1}}}

\begin{document}
\selectlanguage{american}
\begin{wgTitlepage}
  This paper discusses the set of traits we want to ship with \simdT.
\end{wgTitlepage}

\pagestyle{scrheadings}
\section{Introduction}
\textcite{P0214R9} defines the trait \code{simd_abi::deduce<T, N>}\footnote{The trait was called \code{abi_for_size<T, N>} in \textcite{P0214R8}}, allowing users to find an “implementation-recommended” ABI tag for a given \valuetype and number of elements.
\textcite{P0820R1} discusses a use for considering involved ABI tags in the “recommendation”.
SG1 polled in Albuquerque about\\
\wgPoll{\code{abi_for_size_t} (SF) vs. \emph{implementation-defined} (SA)}{1&7&7&0&0}
\noindent The poll result implies that SG1 prefers users to be able to spell out the ABI tags that are determined as return types.
The poll was not about a specific name to use for the trait.
\textcite{P0820R1} suggests to rename the trait to \code{rebind_abi<T, N, Abis...>}.

\section{Motivation}
I believe the name \code{rebind_abi} in \textcite{P0820R1} is misleading, since no rebinding is taking place, but rather a type for implementing a rebind of a given \simd[<T, Abi>] to a different \valuetype \type U is made possible.
Therefore, I propose to
\begin{enumerate}
  \item not rename the \code{simd_abi::deduce} trait in \textcite{P0214R8}, and
  \item extend \code{simd_abi::deduce} to consider input ABI tags in its decision, and
  \item introduce a new trait \code{rebind_simd<U, V>}, which deduces a \simd[<U, Abi>] instantiation from a given \simd type \type V and requested \valuetype \type U.
\end{enumerate}

In addition to \code{rebind_simd}, SG1 should consider whether a \code{resize_simd} trait should be added.
\code{resize_simd_t<N, \simd<T, Abi0>>} is an alias for a \simd[<T, Abi1>] so that \code{simd_size_v<T, Abi1> == N}, and
\code{resize_simd_t<N, \mask<T, Abi0>>} is an alias for a \mask[<T, Abi1>] so that \code{simd_size_v<T, Abi1> == N}.
Since the implementation burden is minimal and the trait can simplify user code, I recommend to add it to the Parallelism TS 2.

\section{Proposed Wording}

Apply the following change to the Parallelism TS 2:
\begin{wgText}[modify {[simd.syn]}]
  \begingroup
    \ttfamily\smaller[1]
    \wgRem{template <class T, size_t N> struct deduce \{ using type = \emph{see below}; \};}\\
    \wgRem{template <class T, size_t N> using deduce_t = typename deduce<T, N>::type;}\\
    \wgAdd{template <class T, size_t N, class... Abis> struct deduce \{ using type = \emph{see below}; \};}\\
    \wgAdd{template <class T, size_t N, class... Abis> using deduce_t = typename deduce<T, N, Abis...>::type;}\\
  \endgroup
\end{wgText}

\begin{wgText}[add to {[simd.syn]}]
  \begingroup
    \ttfamily\smaller[1]
    inline constexpr size_t memory_alignment_v = memory_alignment<T, U>::value;\\
    \wgAdd{}\\
    \wgAdd{template <class T, class V> struct rebind_simd \{ using type = \emph{see below}; \};}\\
    \wgAdd{template <class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;}
    \wgAdd{}\\
    \wgAdd{template <int N, class V> struct resize_simd \{ using type = \emph{see below}; \};}\\
    \wgAdd{template <int N, class V> using resize_simd_t = typename resize_simd<N, V>::type;}
  \endgroup
\end{wgText}

\begin{wgText}[modify {[simd.abi]}]
\begingroup
  \ttfamily\smaller[1]
  \wgRem{template <class T, size_t N> struct deduce \{ using type = \emph{see below}; \};}\\
  \wgAdd{template <class T, size_t N, class... Abis> struct deduce \{ using type = \emph{see below}; \};}
\endgroup
\begin{itemdescr}
  \setcounter{Paras}{7}
  \pnum The member \type{type} shall be present if and only if
  \begin{itemize}
    \item \type T is a \realArithmeticType{}, and
    \item \fixedsizeN is supported (see [simd.abi])\wgAdd{, and}
    \wgItemAdd\wgAdd{every type in the \code{Abis} pack is an ABI tag}.
  \end{itemize}

  \pnum Where present, the member typedef \type{type} shall name an ABI tag type that satisfies
  \begin{itemize}
    \item \code{simd_size_v<T, type> == N}, and
    \item \simd[<T, type>] is default constructible (see \ref{simd.type requirements}),
  \end{itemize}

  If \code{N} is 1, the member typedef \type{type} is \code{simd_abi::scalar}.
  Otherwise, if there are multiple ABI tag types that satisfy the constraints, the member typedef \type{type} is implementation-defined.
  \wgNote{
    It is expected that extended ABI tags can produce better optimizations and thus are preferred over \fixedsizeN.
    \wgAdd{Implementations can base the choice on \code{Abis}, but can also ignore the \code{Abis} arguments.}
  }
\end{itemdescr}
\end{wgText}

\begin{wgText}[add at the end of {[simd.traits]}]
\begingroup
  \ttfamily\smaller[1]
  \wgAdd{template <class T, class V> struct rebind_simd \{ using type = \emph{see below}; \};}
\endgroup
\begin{itemdescr}
  \setcounter{Paras}{14}
  \pnum \wgAdd{The member \type{type} shall be present if and only if}
  \begin{itemize}
    \wgItemAdd\wgAdd{\type{T} is a vectorizable type, and}
    \wgItemAdd\wgAdd{\type{V} is either \type{simd<U, Abi0>} or \type{simd_mask<U, Abi0>}, where \type U and \type{Abi0} are deduced from \type V.}
  \end{itemize}

  \pnum \wgAdd{
    Let \type{Abi1} identify the type \code{deduce_t<T, simd_size_v<U, Abi0>, Abi0>}.
    Where present, the member typedef \type{type} shall name
    \type{simd<T, Abi1>} if \type V is \type{simd<U, Abi0>} or
    \type{simd_mask<T, Abi1>} if \type V is \type{simd_mask<U, Abi0>}.}
\end{itemdescr}

\begingroup
  \ttfamily\smaller[1]
  \wgAdd{template <int N, class V> struct resize_simd \{ using type = \emph{see below}; \};}
\endgroup
\begin{itemdescr}
  \pnum \wgAdd{The member \type{type} shall be present if and only if}
  \begin{itemize}
    \wgItemAdd\wgAdd{\type{V} is either \type{simd<T, Abi0>} or \type{simd_mask<T, Abi0>}, where \type T and \type{Abi0} are deduced from \type V, and}
    \wgItemAdd\wgAdd{\code{simd_abi::deduce<T, N, Abi0>} has a member type \type{type}.}
  \end{itemize}

  \pnum \wgAdd{
    Let \type{Abi1} identify the type \code{deduce_t<T, N, Abi0>}.
    Where present, the member typedef \type{type} shall name \type{simd<T, Abi1>} if \type V is \type{simd<T, Abi0>} or \type{simd_mask<T, Abi1>} if \type V is \type{simd_mask<T, Abi0>}.}
\end{itemdescr}
\end{wgText}

\end{document}
% vim: sw=2 sts=2 ai et tw=0
