\newcommand\wgTitle{Making operator?: overloadable}
\newcommand\wgName{Matthias Kretz <m.kretz@gsi.de>}
\newcommand\wgDocumentNumber{P0917R2}
\newcommand\wgGroup{EWG}
\newcommand\wgTarget{\CC{}23}
%\newcommand\wgAcknowledgements{ }

\usepackage{mymacros}
\usepackage{wg21}
\usepackage{changelog}
\usepackage{underscore}

\addbibresource{extra.bib}

\newcommand\simd[1][]{\type{simd#1}\xspace}
\newcommand\simdT{\type{simd<T>}\xspace}
\newcommand\valuetype{\type{value\_type}\xspace}
\newcommand\referencetype{\type{reference}\xspace}
\newcommand\whereexpression{\type{where\_expression}\xspace}
\newcommand\simdcast{\code{simd\_cast}\xspace}
\newcommand\mask[1][]{\type{simd\_mask#1}\xspace}
\newcommand\maskT{\type{simd\_mask<T>}\xspace}
\newcommand\fixedsizeN{\type{simd\_abi::fixed\_size<N>}\xspace}
\newcommand\fixedsizescoped{\type{simd\_abi::fixed\_size}\xspace}
\newcommand\fixedsize{\type{fixed\_size}\xspace}
\newcommand\simdEP{\code{execution::}\type{simd}\xspace}
\newcommand\seqEP{\code{execution::}\type{seq}\xspace}

\begin{document}
\selectlanguage{american}
\begin{wgTitlepage}
  This paper explores user-defined overloads of \code{operator?:}.
\end{wgTitlepage}

\pagestyle{scrheadings}
\section{Introduction}
Most operators in \CC{} can be overloaded.
The few exceptions are: \code{?:}, \code{::}, \code{.}, \code{.*}.
For the conditional operator, \textcite{StrFaq} writes:
“There is no fundamental reason to disallow overloading of \code{?:}.
I just didn't see the need to introduce the special case of overloading a ternary operator.
Note that a function overloading \code{expr1?expr2:expr3} would not be able to guarantee that only one of \code{expr2} and \code{expr3} was executed.”
In this paper I want to show a need for overloading the conditional operator.

It is important to consider \code{std::common_type} when discussing changes to the conditional operator.
\code{common_type_t<T, U>} basically is defined as \code{decltype(false ? : T() : U())}.
Consequently, if the conditional operator supports more types via user-defined overloads, \code{common_type} would automatically support them as well.

A previous revision of this paper discussed how to enable deferred evaluation.
But since \textcite{P0927R2} is trying to solve deferred evaluation in general, this paper will instead rely on the facilities of \cite{P0927R2}.

\section{Motivation}
\subsection{Be General}
“Don’t restrict what is inherent.
Don’t arbitrarily restrict a complete set of uses.
Avoid special cases and partial features.” \cite{P0745R0}

\CC{} allows operator overloading for almost all operators.
Operator-dot overloading is under consideration in the committee \cite{P0352R1,P0416R1}.
This leaves \code{operator?:} as the last missing piece.

\subsection{Blend Operations}
The conditional operator is a perfect match for expressing blend operations generically, i.e. such that a function template also works with fundamental types.
Consider \type{simd<T, Abi>} \cite[§9]{N4808}, where a certain number (determined at compile time) of values of arithmetic type \type T are combined to a single object.
All operators act element-wise and concurrently.
Thus, the meaning of
\smallskip\begin{lstlisting}[style=Vc]
template <class T> T abs(T x) {
  return x < 0 ? -x : x;
}
\end{lstlisting}
intuitively translates from fundamental types to \type{simd} types:
Element-wise application of the conditional operator blends the elements of \code{-x} and \code x into a single \type{simd} object according to the \type{simd_mask} object (\code{x < 0}).
The alternative solution for \type{simd} blend operations is to use a function, such as “inline-if”:
\smallskip\begin{lstlisting}[style=Vc]
template <class T> T abs(T x) {
  return iif(x < 0, -x, x);
}
\end{lstlisting}
An “inline-if” function is
\begin{itemize}
  \item less intuitive, since the name is either long or it is cryptic, and the arguments appear to be arbitrarily ordered (comma doesn't convey semantics such as \code ? and \code : do).
  \item harder to use in generic code:
    If \type T is a built-in type, the \code{iif} function will not be found via ADL; consequently, user code requires \code{return std::experimental::iif(x < 0, -x, x)} to be generic.
    This is annoying and easily forgotten since ADL works fine for \type{simd} arguments.
\end{itemize}

It is not possible (and not a good idea to extend the language in such a way, in my opinion) to overload \code{if} statements and iteration statements for non-boolean conditions.
Thus, to support any “collection of \bool{}”-like type in conditional expressions using built-in syntax, the conditional operator is the only candidate.

Considering cases where generality of the syntax, i.e. extension from the built-in case to user-defined types, is important, we see that all such use cases will have a type for the condition that is not contextually convertible to \bool because the user-defined condition object stores multiple boolean states.
Overloading the conditional operator is thus most interesting for stating conditional evaluation of multiple data sets without imposing an order and thus enabling parallelization.

\subsection{Embedded Domain Specific Languages}
Embedded domain specific languages in \CC{} often redefine operators for user-defined types to create a new language embedded into \CC{}.
Having the conditional operator available makes \CC{} more versatile for such uses.
Most sensible uses of the conditional operator will likely be similar to the “blend operations” case discussed for \type{simd} types, though.
The motivation is not as strong as in the above case, since in most cases substitutability of the code to fundamental types is not a goal.

\subsection{User-defined numeric types}
Any library-based numeric type may have a need for overloading \code{operator?:} if the type carries information about the value or even modifies the value (e.g. for \code{std::chrono::duration}).
Most of those types specialize \type{std::common_type}\footnote{cf. \url{https://codesearch.isocpp.org/cgi-bin/cgi_ppsearch?q=struct+common_type\%3C&search=Search
}}.
Examples:
\begin{itemize}
  \item \code{std::chrono::duration<Rep, Period>}
  \item \code{std::chrono::time_point<Clock, Duration>}
  \item \code{fractional<Numerator, Denominator>} from \cite{P1050R0}
  \item \code{fixed_point<Rep, Exponent, Radix>} from \cite{P0037R5}
  \item \code{bounded::integer<minimum, maximum>} from \cite{site.bounded-integer}
\end{itemize}

Consider the \code{bounded::integer} example (cf. \cite{site.bounded-integer}):
\smallskip\begin{lstlisting}[style=Vc,escapeinside={/*!}{*/},numbers=left]
bounded::integer<1, 100> const a = f();
bounded::integer<-3, 7> const b = g();
bounded::integer<-2, 107> c = a + b;  /*!\label{lst:ok}*/
bounded::integer<-3, 100> d = some_condition ? a : b;  /*!\label{lst:notok}*/
\end{lstlisting}

Line \ref{lst:ok} is what the \code{bounded::integer} library can currently do for you.
However, line \ref{lst:notok} is currently not possible since it would require more control by the library over the types involved (arguments and result) with the conditional operator.

Any design that wants to allow different types on the second and third argument (without implicit conversions), and determine a return type from them, requires an overloadable conditional operator.
Note that user-defined numeric types want a signature such as \code{operator?:(std::Boolean, T1, T2)} in most cases.
I.e. the idea to only allow non-\bool conditions on \code{operator?:} overloads breaks this use case.
(I mentioned the idea in the previous revisions and it was also suggested in EWGI discussion).

\subsection{Existing Practice}
GCC implements support for the conditional operator to allowing blending its vector builtins\footnote{\url{https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html}}.
OpenCL uses the conditional operator for blending operations \cite{spec.opencl1.1}.
Allowing overloads of \code{operator?:} in \CC{} would enable users and \type{std::simd} to implement blend semantics with the same syntax and semantics as provided by GCC and OpenCL.

\section{Exploration}

\subsection{Can a user-defined conditional operator change existing code?}

The conditional operator already works in many situations where user-defined types are used.
A few examples are shown in \fig{udt-cond-examples}.
\begin{figure}[bht]\begin{lstlisting}
// most common usage of ?: with UDTs:
struct Point { float x, y, z; };
static_assert(is_same_v<Point, decltype(bool() ? Point() : Point())>);

// less common:
struct A { explicit operator bool(); };
struct B { operator float(); };
struct C { operator float(); };
using X = decltype(A() ? B() : C());  // X = float (GCC, Clang), double (ICC),
                                      //     ill-formed (MSVC)
struct D {
  operator B();
  operator float();
};
using Y = decltype(A() ? B() : D());  // Y = B
struct E;
struct F { operator E(); };
struct E { operator F(); };
using Z = decltype(A() ? F() : E());  // Z = F (MSVC), ill-formed (GCC, Clang, ICC)
\end{lstlisting}
\caption{Examples of the conditional operator with UDTs}
\label{fig:udt-cond-examples}
\end{figure}

Should the user be able to define a conditional operator that takes precedence over the built-in operator?
Of course, to be consistent with all other operator overloads, \code{operator?:} overloads will require at least one user-defined type in their signature.
The examples in \fig{udt-cond-examples} seem to motivate maximal freedom in overloading \code{operator?:}; but let's not use implementation divergence for motivation.

If we allow user-defined \code{operator?:} to be a better match than built-in \code{operator?:}, we open the door to situations where the return type (and value) of the same conditional operator is different at different places in the TU (such as in \url{https://godbolt.org/z/xMMbaE}), as is the case for all other operators already.
However, \type{common_type} behaves differently, since it can only be specialized once.
Consequently, if a user-defined conditional operator were allowed to overload combinations that the built-in operator can handle, one could construct examples where \type{common_type<A, B>} and \code{decltype(false ? A() : B())} agree in one part of the TU and disagree in the other part.%
\footnote{\code{using X = common_type_t<A, B>; /*overload operator?:(bool, A, B)*/ static_assert(is_same_v<common_type_t<A, B>, decltype(false ? A() : B())>);}}
Note that such pitfalls are not novel.
All operator (and function) overloads can already be used to construct such inconsistencies (e.g. \fig{operator+}).

\begin{figure}[bht]
  \begin{lstlisting}[style=Vc]
struct A { operator int() const; };
struct B { operator float() const; };

template <class A, class B> struct my_common_type {
  using type = decltype(A() + B());
};
template <class A, class B>
using my_common_type_t = typename my_common_type<A, B>::type;

using X = my_common_type_t<A, B>;
static_assert(std::is_same_v<X, my_common_type_t<A, B>>);
static_assert(std::is_same_v<X, decltype(A() + B())>);

short operator+(A, B);
static_assert(std::is_same_v<X, my_common_type_t<A, B>>);
static_assert(std::is_same_v<X, decltype(A() + B())>);  // fails
  \end{lstlisting}
  \caption{A pitfall of overloading (cf. \url{https://godbolt.org/z/iqbj1a})}
  \label{fig:operator+}
\end{figure}

Nevertheless, because of the connection between \type{common_type} and the conditional operator, I believe we should consider the possibility of disregarding user-defined operators whenever the built-in operator is a candidate.
It would be nicer to make the declaration of such operator overloads ill-formed.
But I believe this is impossible since it appears to be a similar problem as definition checking for concepts.
We could, however, consider to make such operator overload declarations ill-formed NDR.

That said, I believe such a constraint on \code{operator?:} is complicating the language for little gain and might even inhibit a valid use cases.
I would prefer to make \code{operator?:} just as useful and dangerous as all other overloads.
Suggested poll: “\code{operator?:} should have special rules to avoid overloading the built-in operator”.

\subsection{Should \type{common_type} ignore user-defined conditional operators?}
Currently, \code{std::common_type} is specified in terms of the \code{decltype} of the conditional operator.
Consequently, if the \code{common_type} specification is not changed, the declaration of user-defined conditional operators affects the result of \code{common_type}.
I strongly believe this is the preferred behavior.
Either \code{common_type} specializations should extend \code{operator?:} or \code{operator?:} overloads should extend \code{common_type}.
The inconsistency we currently have from user-defined specializations of \code{common_type} is suboptimal (i.e. a common type is defined, but the conditional operator still is not usable).
The DRY (“don't repeat yourself”) principle implies we should enable a way for users to extend \code{operator?:} and \code{common_type} with a single definition.
The more flexible and natural customization point is \code{operator?:}.

%\subsection{Implications for “contextually convertible to \bool” tests}
%A possible implementation of testing for “contextually convertible to \bool{}” makes use of SFINAE on the conditional operator as shown in \fig{ccb trait}.
%(“The first expression is contextually converted to \bool.” \cite[{[expr.cond]}]{N4810})
%\begin{figure}[bht]
%\begin{lstlisting}
%template <class T, class = void>
%  constexpr bool ccb = false;
%template <class T>
%  constexpr bool ccb<T, std::void_t<decltype(std::declval<T>() ? 1 : 2)>> = true;
%\end{lstlisting}
%\caption{Naïve trait to test whether \type T is contextually convertible to \bool.}
%  \label{fig:ccb trait}
%\end{figure}
%
%GCC implements an overload of the conditional operator for \code{[[gnu::vector_size(N)]]} types.
%Consequently, the trait as defined in \fig{ccb trait} does not always produce the correct result.
%\begin{figure}[bht]
%\begin{lstlisting}
%template <class T>
%  using V [[gnu::vector_size(16)]] = T;
%
%bool x[] = {
%  ccb<bool>,               // true
%  ccb<int>,                // true
%  ccb<std::array<int, 4>>, // false
%  ccb<V<int>>,             // true
%  ccb<V<unsigned>>,        // true
%  ccb<V<short>>,           // false
%};
%\end{lstlisting}
%\caption{Results of the trait from \fig{ccb trait} (\url{https://godbolt.org/z/DhTocm}).}
%  \label{fig:bad ccb}
%\end{figure}
%In \fig{bad ccb}, \code{V<int>} is not contextually convertible to \bool --- the \code{ccb} trait as defined in \fig{ccb trait} is incorrect.
%However, as \fig{better ccb trait} shows, the trait can be adjusted to use a type on the right hand side that is more likely not to trigger any other conditional operator overload.
%\begin{figure}[bht]
%\begin{lstlisting}[style=Vc]
%struct _CcbTest {};
%template <class T, class = _CcbTest>
%  constexpr bool ccb = false;
%template <class T>
%  constexpr bool ccb<T, decltype(std::declval<T>() ? _CcbTest() : _CcbTest())> = true;
%\end{lstlisting}
%  \caption{Safer trait to test whether \type T is contextually convertible to \bool (\url{https://godbolt.org/z/WqT_1B}).}
%  \label{fig:better ccb trait}
%\end{figure}
%
%Thus, I believe user-defined conditional operators do not break the ability to define a “contextually convertible to \bool{}” trait.

\subsection{Deferred evaluation}
One of the expected features of the conditional operator is deferred evaluation of the expressions after the question mark.
However, deferred evaluation is an orthogonal problem, and best handled via an independent proposal such as \cite{P0927R2}.
A desire to first solve deferred evaluation before deciding on overloading the conditional operator was voiced a few times.
I strongly believe \code{operator?:} overloading is worthwhile even if \cite{P0927R2} (or a different facility solving that same problem) does not move forward.
This is because a major part of the motivation for \code{operator?:} overloading is for blend operations.
Blend operations cannot make use of deferred evaluation and thus can benefit from the simplest way of \code{operator?:} overloading.

Consider a conceivable implementation of the conditional operator for \type{simd<T, Abi>} as shown in \fig{simd ?:}.
\begin{figure}[bht]
\begin{lstlisting}[style=Vc]
template <class T, class Abi>
simd<T, Abi> operator?:(simd_mask<T, Abi> mask, simd<T, Abi> a, simd<T, Abi> b) {
  if (all_of(mask)) [[unlikely]] {
    return a;
  } else if (none_of(mask)) [[unlikely]] {
    return b;
  }
  where(mask, b) = a;
  return b;
}
\end{lstlisting}
\caption{Simple \code{operator?:} for \type{simd<T, Abi>}}
  \label{fig:simd ?:}
\end{figure}
If this code is inlined\footnote{A reasonable \code{simd} implementation forces inlining for most functions.}, the compiler will know how to improve the calling code without the need for explicit deferred evaluation of \code a and \code b.
Only if the expressions in the second and third argument to the conditional operator have side effects, is the difference important.\footnote{Side effects in those expressions are likely bugs anyway (printf debugging maybe being an exception)}

Pure numerical code (thus without side effects) can also optimize a simple conditional operator that does not make use of deferred evaluation.
For expression templates, \code{operator?:} overloads can and have to implement deferred evaluation themselves anyway.

%Consider a possible implementation of the conditional operator for \code{bounded::integer} as shown in \fig{bounded integer ?:}:
%\begin{figure}[bht]
%\begin{lstlisting}
%template <std::Boolean B, BoundedInteger T0, BoundedInteger T1>
%common_type_and_value_category_t<T0, T1> operator?:(B cond, T0 a, T1 b) {
%  return cond ? static_cast<common_type_and_value_category_t<T0, T1>>(a)
%              : static_cast<common_type_and_value_category_t<T0, T1>>(b);
%}
%\end{lstlisting}
%\caption{Simple \code{operator?:} for \type{bounded::integer>}}
%\label{fig:bounded integer ?:}
%\end{figure}
%Again, inlining can cover all the important cases (i.e. all but side effects).

\section{Wording}
TBD.

\input{changelog}
\input{strawpolls}

\end{document}
% vim: sw=2 sts=2 ai et tw=0
