\section{Wording}

The following is a rough draft of possible wording that defines a basic set of data-parallel types.

\begin{wgText}
  \wgSection{Data-Parallel Types}{datapar.types}

  \wgSubsection{Header \code{<datapar>} synopsis}{datapar.syn}
  \lstinputlisting[]{synopsis.cpp}

  \pnum
  The header \code{<datapar>} defines two class templates (\datapar, and \mask), several tag types, and a series of related function templates for concurrent manipulation of the values in \datapar and \mask objects.

  \begin{itemdecl}
namespace datapar_target {
  struct scalar {};
  // implementation-defined tag types, e.g. sse, avx, avx512, neon, ...
  typedef implementation_defined widest;
}
  \end{itemdecl}
  \begin{itemdescr}
    \pnum
    The target types are tag types to be used as the second template argument to \datapar and \mask.

    \pnum
    The \type{scalar} tag is present in all implementations and forces \datapar and \mask to store a single component (i.e. \datapar{}\type{<T, datapar_target::scalar>::size()} returns \code 1).

    \pnum
    An implementation may choose to implement data-parallel execution for many different targets.
    All tag types this implementation supports shall be present independent of the chosen target.
    %\wgNote{This means that if the type \type{datapar_target::abc} is implemented for the \emph{abc} target system, compilation for the target \emph{xyz} will also have the \type{datapar_target::abc} tag type.}

    \pnum
    The \type{datapar_target::widest} tag is defined by the implementation to alias the tag type with the most efficient data parallel execution.
  \end{itemdescr}

  \begin{itemdecl}
template <size_t> struct target_for_width {
  typedef implementation_defined type;
};
  \end{itemdecl}
  \begin{itemdescr}
    \pnum
    The \type{target_for_width} class template defines the member type \type{type} to one of the tag types in \code{datapar_target} or not at all, depending on the value of the template parameters.

    \pnum
    \code{datapar<T, target_for_width_t<T, N>>::size()} must return \code N or result in a substitution failure.
  \end{itemdescr}

  \wgSubsection{Class template \datapar}{datapar}
  \wgSubsubsection{Class template \datapar overview}{datapar.overview}
  \lstinputlisting[]{datapar.cpp}

  \pnum The class template \datapar{}\type{<T, Target>} is a one-dimensional smart array.
  In contrast to \type{valarray} (26.6), the number of elements in the array is determined at compile time, according to the \type{Target} template parameter.

  \pnum The first template argument \type T must be an integral or floating-point fundamental type.
  The type \bool is not allowed.

  \pnum The second template argument \type{Target} must be a tag type from the \code{datapar_target} namespace.

  \begin{itemdecl}
typedef implementation_defined internal_type;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum
    The \type{internal_type} member type is an alias for the \code{internal()} member function return type.
    It is used to expose an implementation-defined handle for implementation- and target-specific extensions.
  \end{itemdescr}

  \begin{itemdecl}
typedef implementation_defined register_value_type;
  \end{itemdecl}
  \begin{itemdescr}
  \end{itemdescr}

  \wgSubsubsection{\datapar constructors}{datapar.ctor}
  \begin{itemdecl}
datapar() = default;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum
    \effects
    Constructs an object with all elements initialized to \code{T()}.
    \wgNote{This zero-initializes the object.}
  \end{itemdescr}

  \begin{itemdecl}
datapar(value_type);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum
    \effects
    Constructs an object with each element initialized to the value of the argument.
  \end{itemdescr}

  \begin{itemdecl}
template <typename U> datapar(datapar<U, Target> x);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum
    \effects
    Constructs an object with the $i$-th element initialized to \code{static_cast<T>(x[i])} for all elements.
  \end{itemdescr}

  \wgSubsubsection{\datapar load functions}{datapar.load}
  \begin{itemdecl}
static datapar load(const value_type *x);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum \effects Constructs an object with each element $i$ initialized to \code{x[i]} for all elements.
    \pnum \returns The constructed object.
    \pnum \remarks If \datapar{}\code{::size()} is greater than the number of values pointed to by the argument, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
template <typename Flags> static datapar load(const value_type *x, Flags);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Constructs an object with each element $i$ initialized to \code{x[i]}.
    \pnum\returns The constructed object.
    \pnum\remarks If \datapar{}\code{::size()} is greater than the number of values pointed to by the first argument, the behavior is undefined.
    \pnum         If the template parameter is of type \type{aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\type T>}, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
template <typename U, typename Flags = unaligned_tag> static datapar load(const U *x, Flags = Flags());
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Constructs an object with each element $i$ initialized to \code{static_cast<T>(x[i])}.
    \pnum\returns The constructed object.
    \pnum\remarks If \datapar{}\code{::size()} is greater than the number of values pointed to by the first argument, the behavior is undefined.
    \pnum         If the second template parameter is of type \type{aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\type U>}, the behavior is undefined.
  \end{itemdescr}

  \wgSubsubsection{\datapar store functions}{datapar.store}
  \begin{itemdecl}
void store(value_type *x);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Copies each element such that the $i$-th element is stored to \code{x[i]}.
    \pnum\remarks If \datapar{}\code{::size()} is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
template <typename Flags> void store(value_type *x, Flags);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Copies each element such that the $i$-th element is stored to \code{x[i]}.
    \pnum\remarks If \datapar{}\code{::size()} is greater than the number of values pointed to by the first argument, the behavior is undefined.
    \pnum         If the template parameter is of type \type{aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\type T>}, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
template <typename U, typename Flags = unaligned_tag> void store(U *x, Flags = Flags());
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Copies each element such that the $i$-th element is first converted to \type U and then stored to \code{x[i]}.
    \pnum\remarks If \datapar{}\code{::size()} is greater than the number of values pointed to by the first argument, the behavior is undefined.
    \pnum         If the second template parameter is of type \type{aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\type U>}, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
void store(value_type *x, mask_type);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Copies each element where the corresponding element in the second argument is \true such that the $i$-th element is stored to \code{x[i]}.
    \pnum\remarks If the largest $i$ where the second argument is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
template <typename Flags> void store(value_type *x, mask_type, Flags);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Copies each element where the corresponding element in the second argument is \true such that the $i$-th element is stored to \code{x[i]}.
    \pnum\remarks If the largest $i$ where the second argument is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
    \pnum         If the template parameter is of type \type{aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\type T>}, the behavior is undefined.
  \end{itemdescr}

  \begin{itemdecl}
template <typename U, typename Flags = unaligned_tag> void store(U *x, mask_type, Flags = Flags());
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Copies each element where the corresponding element in the second argument is \true such that the $i$-th element is first converted to \type U and then stored to \code{x[i]}.
    \pnum\remarks If the largest $i$ where the second argument is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
    \pnum         If the template parameter is of type \type{aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\type U>}, the behavior is undefined.
  \end{itemdescr}

  \wgSubsubsection{\datapar subscript operators}{datapar.subscr}
  \begin{itemdecl}
reference operator[](size_type i);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\returns An lvalue reference to the $i$-th element.
    \pnum\postconditions Assignment of objects of type \type T modify the $i$-th element without aliasing violations.
    \pnum                Modification of \code{*this} does not invalidate references held to the return value.
    Subsequent reads from such references yield the new value of the $i$-th element.
  \end{itemdescr}

  \begin{itemdecl}
const_reference operator[](size_type) const;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\returns A \const lvalue reference to the $i$-th element.
    \pnum\postconditions Modification of \code{*this} does not invalidate references held to the return value.
    Subsequent reads from such references yield the new value of the $i$-th element.
  \end{itemdescr}

  \wgSubsubsection{\datapar unary operators}{datapar.unary}
  \begin{itemdecl}
datapar &operator++();
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Increments every element of \code{*this} by one.
    \pnum\returns An lvalue reference to \code{*this} after incrementing.
    \pnum\remarks Overflow semantics follow the same semantics as for \type T.
  \end{itemdescr}

  \begin{itemdecl}
datapar operator++(int);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Increments every element of \code{*this} by one.
    \pnum\returns A copy of \code{*this} before incrementing.
    \pnum\remarks Overflow semantics follow the same semantics as for \type T.
  \end{itemdescr}

  \begin{itemdecl}
datapar &operator--();
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Decrements every element of \code{*this} by one.
    \pnum\returns An lvalue reference to \code{*this} after decrementing.
    \pnum\remarks Underflow semantics follow the same semantics as for \type T.
  \end{itemdescr}

  \begin{itemdecl}
datapar operator--(int);
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Decrements every element of \code{*this} by one.
    \pnum\returns A copy of \code{*this} before decrementing.
    \pnum\remarks Underflow semantics follow the same semantics as for \type T.
  \end{itemdescr}

  \begin{itemdecl}
mask_type operator!() const;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\returns A mask object with the $i$-th element set to \code{!operator[](i)} for all elements.
  \end{itemdescr}

  \begin{itemdecl}
datapar operator~() const;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\requires The first template argument \type T to \datapar must be an integral type.
    \pnum\effects Constructs an object where each bit of \code{*this} is inverted.
    \pnum\returns The new object.
    \pnum\remarks \datapar{}\code{operator~()} shall not participate in overload resolution if \type T is a floating-point type.
  \end{itemdescr}

  \begin{itemdecl}
datapar operator+() const;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum \returns A copy of \code{*this}
  \end{itemdescr}

  \begin{itemdecl}
datapar operator-() const;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\effects Constructs an object where the $i$-th element is initialized to \code{-operator[](i)} for all elements.
    \pnum\returns The new object.
  \end{itemdescr}

  \wgSubsubsection{\datapar internal handles}{datapar.intern}
  \begin{itemdecl}
internal_type &internal();
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\returns An lvalue reference to the implementation-specific object implementing the data-parallel semantics.
  \end{itemdescr}

  \begin{itemdecl}
const internal_type &internal() const;
  \end{itemdecl}
  \begin{itemdescr}
    \pnum\returns A \const lvalue reference to the implementation-specific object implementing the data-parallel semantics.
  \end{itemdescr}

  \wgSubsection{Class template \mask}{datapar.mask}
  \lstinputlisting[]{mask.cpp}

\end{wgText}
