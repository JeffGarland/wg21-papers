\newcommand\wgTitle{Expected Feedback from \code{simd} in the Parallelism TS 2}
\newcommand\wgName{Matthias Kretz <m.kretz@gsi.de>}
\newcommand\wgDocumentNumber{DXXXXR0}
\newcommand\wgGroup{SG1 / LEWG}
%\newcommand\wgTarget{Parallelism TS 2}
%\newcommand\wgAcknowledgements{ }

\usepackage{mymacros}
\usepackage{wg21}
\usepackage{underscore}

\addbibresource{extra.bib}

\newcommand\simd[1][]{\type{simd#1}\xspace}
\newcommand\simdT{\type{simd<T>}\xspace}
\newcommand\valuetype{\type{value\_type}\xspace}
\newcommand\referencetype{\type{reference}\xspace}
\newcommand\whereexpression{\type{where\_expression}\xspace}
\newcommand\simdcast{\code{simd\_cast}\xspace}
\newcommand\mask[1][]{\type{simd\_mask#1}\xspace}
\newcommand\maskT{\type{simd\_mask<T>}\xspace}
\newcommand\fixedsizeN{\type{simd\_abi::fixed\_size<N>}\xspace}
\newcommand\fixedsizescoped{\type{simd\_abi::fixed\_size}\xspace}
\newcommand\fixedsize{\type{fixed\_size}\xspace}
\newcommand\simdEP{\code{execution::}\type{simd}\xspace}
\newcommand\seqEP{\code{execution::}\type{seq}\xspace}

\usepackage{pifont}

\newcommand\chck{\item[\color{black}\ensuremath{\checkmark}]}
\newcommand\todo{\item[\color{black}\ding{46}] \color{gray}}
\newcommand\itemheader[1]{\item[] \hfill \textcolor{gray}{\textsc{#1}}}

\begin{document}
\selectlanguage{american}
\begin{wgTitlepage}
  This paper collects the questions we hope to answer via the TS process.
\end{wgTitlepage}

\pagestyle{scrheadings}
\section{Introduction}
\cite{N4744} introduces type-based expression of data parallelism.
Through the TS process we hope to get feedback on a number of issues that were not clear to the committee before hands-on experience.
This paper collects the questions and design choices that SG1 / LEWG might want to revisit before moving \simdT into the IS.

\section{Questions}

\subsection{Names of \code{popcount}, \code{find_first}, \code{find_last}}
\url{https://github.com/mattkretz/wg21-papers/issues/63}
These need to be consistent and unambiguous with the corresponding functions introduced for builtin types.

\subsection{Names \code{copy_from}, \code{copy_to}}
\url{https://github.com/mattkretz/wg21-papers/issues/62}
The names were discussed in SG1 and LEWG.
If there is no new information via experience, WG21 should not spend any further time on renaming these functions.
Consequently, this is a call for feedback from usage experience.
We need arguments why a certain name works or does not work (clarity, ambiguity); no calls for preference.

\subsection{Name of \code{where} function}
\url{https://github.com/mattkretz/wg21-papers/issues/61}
The name was discussed in LEWG.
If there is no new information via experience, WG21 should not spend any further time on renaming this function.
Consequently, this is a call for feedback from usage experience.
We need arguments why a certain name works or does not work (clarity, ambiguity); no calls for preference.

\subsection{Name of \simdT misleading?}
\url{https://github.com/mattkretz/wg21-papers/issues/60}
The name was discussed in SG1 and LEWG.
SG1 chose \code{datapar} over \code{simd} and other options.
LEWG overruled that choice and renamed it to \code{simd}.

We should use the TS to discover the following:
\begin{itemize}
  \item Is there interest in implementations that use hardware parallelism that does not map (exclusively) to SIMD instructions \& registers?
    \begin{flushright}
      \smaller\color{gray}
      I believe \code{fixed_size} itself is already a manifestation of such a feature.
      Furthermore the libc++ and libstdc++ implementations, at least, are investing in ABIs that allow combining N SIMD registers into one \code{simd} type.
    \end{flushright}
  \item Do users choose to not use \code{simd}, because it appears too narrowly focused (from its name) on (certain) CPUs?
    Would such users choose differently if the name would focus on the parallelism it allows instead of a specific hardware implementation of such parallelism?
\end{itemize}

\subsection{\code{fixed_size} vs. \code{deduce_t}}
\url{https://github.com/mattkretz/wg21-papers/issues/59}
Whenever the interface requires a \simd type that has a specific number of elements (typically deduced from one or more native types), we have a choice:
\begin{itemize}
  \item Use \fixedsizeN.
    This is easy to memorize and understand.
    However, \fixedsizeN may be less efficient if such objects have to pass a function call boundary.
    Also, absent more implicit conversions, users that prefer native types will have to use an explicit cast.
  \item Use \code{simd_abi::deduce_t<T, N, Abis...>}.
    It is less obvious what the exact type will be (native or \fixedsizeN) and the choice will be target-dependent.%
    \footnote{Note that an implementation might deduce an ABI tag that is not \fixedsizeN for all combinations of \type T and \code N.}
    This makes it slightly harder to write portable code (typically the logic is portable, it just needs an additional cast for some targets).
    The portability issue could be reduced by allowing more implicit casts.
\end{itemize}

\subsection{Return types of split and concat unconditionally \fixedsizeN?}
\url{https://github.com/mattkretz/wg21-papers/issues/59}

\subsection{Consider more implicit conversions}
\url{https://github.com/mattkretz/wg21-papers/issues/26} and \url{https://github.com/mattkretz/wg21-papers/issues/3}

\subsection{Allowed template arguments for (\code{static_})\code{simd_cast}}
\url{https://github.com/mattkretz/wg21-papers/issues/57}

\subsection{Should there really be no default for the load/store flags}
\begin{lstlisting}[numbers=left]
std::simd<float> v(addr, std::vector_aligned); @\label{lstline:vector_aligned}@
v.copy_from(addr + 1, std::element_aligned); @\label{lstline:load element_aligned}@
v.copy_to(dest, std::element_aligned); @\label{lstline:store element_aligned}@
\end{lstlisting}
Line \ref{lstline:vector_aligned} supplies an optimization hint.
Line \ref{lstline:load element_aligned} says what really?
“Please don't crash.
I'm sure this is not a vector aligned access\footnote{Not true, it still is vector aligned if \code{simd<float>::size() == 1}}.”
line \ref{lstline:store element_aligned} says:
“I don't know whether it's vector aligned or not.
Compiler if you know more, please optimize, otherwise just don't make it crash.”

Since \CC{}20, we have another option:
\begin{lstlisting}[numbers=left]
std::simd<float> v(std::assume_aligned<std::memory_alignment_v<std::simd<float>>>(addr)); @\label{lstline:assume_aligned}@
v.copy_from(addr + 1);
v.copy_to(dest);
\end{lstlisting}
This seems to compose well, except that line \ref{lstline:assume_aligned} is rather long for a common pattern in this interface.
Also, this removes implementation freedom because the library cannot statically determine the alignment properties of the pointer.

Consequently, I suggest to keep the load/store flags as in the TS but default them to \code{element_aligned}.
I.e.:
\begin{lstlisting}[numbers=left]
std::simd<float> v(addr, std::vector_aligned);
v.copy_from(addr + 1);
v.copy_to(dest);
\end{lstlisting}

\subsection{Should converting loads/stores be safer wrt. conversions}
\url{https://github.com/mattkretz/wg21-papers/issues/34}

Since implicit conversions on broadcasts are restricted to value-preserving conversions, the load/store interface is inconsistent with this strictness.
I.e.:

\begin{lstlisting}[style=Vc]
using V = simd<float>;
V(1.);  // error, double -> float conversion is not value-preserving
V(short(1));  // good, short -> float is value-preserving
double mem[V::size()] = {1.};
V(mem, flags::element_aligned);  // converting load, compiles (but shouldn't?)
short mem[V::size()] = {1};
V(mem, flags::element_aligned);  // value-preserving conversion, should compile?
\end{lstlisting}

The conversion is not obvious when you look at the line of code that requests the load.

Options:
\begin{enumerate}
  \item Drop converting loads and stores.
    (That would be unfortunate, since doing converting loads and stores efficiently and portably is otherwise a hard problem.)

  \item Use different functions, e.g. \code{v.copy_from(mem, flags)} requires \code{mem} to be a \valuetype array. \code{v.memload_cvt_safe(mem, flags)} allows value-preserving conversions.
    \code{v.memload_cvt_unsafe(mem, flags)} allows all conversions.

  \item Use a flag to enable conversions (without cvt flag, no conversions are allowed), e.g.
    \begin{lstlisting}[style=Vc]
    V(mem, flags::element_aligned | flags::safe_cvt);
    V(mem, flags::element_aligned | flags::any_cvt);
    V(mem, flags::element_aligned | flags::saturating_cvt);  // new feature
    \end{lstlisting}
    As a variation, safe conversions could be enabled per default and only unsafe conversions would require extra typing.

\end{enumerate}

\subsection{Relation Operators}
\textcite{P0820R1} argues for a substantial change to the definition of relation operators.
\textcite{P0851R0} presents the reason for the status quo.
The choices are:
\begin{enumerate}
  \item All relops are defined and return \mask (status quo).
  \item Compares returning \mask are provided via new functions (member vs. non-member?)
    \begin{enumerate}
      \item No relops are defined.
      \item \code{operator==} and \code{operator!=} are defined and return \bool.
    \end{enumerate}
\end{enumerate}

\end{document}
% vim: sw=2 sts=2 ai et tw=0
