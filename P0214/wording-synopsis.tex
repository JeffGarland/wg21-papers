\wgSubsection{Header \code{<datapar>} synopsis}{datapar.syn}
\lstinputlisting[]{synopsis.cpp}

\pnum
The header \code{<datapar>} defines the class templates (\datapar, \mask, and \type{where_expression}), several tag types, and a series of related function templates for concurrent manipulation of the values in \datapar and \mask objects.

\wgSubsubsection{\datapar ABI tags}{datapar.abi}

\begin{itemdecl}
namespace datapar_abi {
  struct scalar {};
  template <int N> struct fixed_size {};
  template <typename T> constexpr int max_fixed_size = implementation-defined;
  template <typename T> using compatible = implementation-defined;
  template <typename T> using native = implementation-defined;
}
\end{itemdecl}
\begin{itemdescr}
  \pnum
  An \emph{ABI tag} type indicates a choice of target-architecture dependent size and binary representation for \datapar and \mask objects.
  The ABI tag, together with a given element type implies a number of elements.
  ABI tag types are used as the second template argument to \datapar and \mask.
  \wgNote{
    The ABI tag is orthogonal to selecting the machine instruction set.
    The selected machine instruction set limits the usable ABI tag types, though (see \ref{datapar.type requirements}).
    The ABI tags enable users to safely pass \datapar and \mask objects between translation unit boundaries (e.g. function calls or I/O).
  }

  \pnum
  Use of the \type{scalar} tag type forces \datapar and \mask to store a single component (i.e. \datapar{}\type{<T, datapar_abi::scalar>::size()} returns \code 1).
  \wgNote{\type{scalar} shall not be an alias for \type{fixed_size<1>}.}

  \pnum\label{datapar.fixedsize.def}%
  Use of the \fixedsizeN tag type forces \datapar and \mask to store and manipulate \code N components (i.e. \datapar{}\type{<T, \fixedsizeN{}>::size()} returns \code N).
  An implementation must support at least any \code N $\in [1\ldots 32]$.
  Additionally, for every supported \datapar[<T, A>] (see \ref{datapar.type requirements}), where \type A is an implementation-defined ABI tag, \code N $=$ \datapar[<T, A>::size()] must be supported.

  \wgNote{
    An implementation may choose to forego ABI compatibility between differently compiled translation units for \datapar and \mask instantiations using the same \fixedsizeN tag.
    Otherwise, the efficiency of \datapar[<T, Abi>] is likely to be better than for \datapar[<T, fixed_size<datapar_size_v<T, Abi>>>] (with \type{Abi} not a instance of \fixedsizescoped).
  }

  \pnum\label{datapar.maxfixedsize.def}%
  The value of \code{max_fixed_size<T>} declares that an instance of \datapar[<T, fixed_size<N>>] with \code{N <= max_fixed_size<T>} is supported by the implementation.
  \wgNote{It is unspecified whether an implementation supports \datapar[<T, fixed_size<N>>] with \code{N > max_fixed_size<T>}.}

  \pnum
  An implementation may define additional ABI tag types in the datapar_abi namespace, to support other forms of data-parallel computation.

  \pnum
  \type{datapar_abi::compatible<T>} is an alias for the ABI tag with the most efficient data parallel execution for the element type \type T that ensures ABI compatibility on the target architecture.

  \wgExample{
    Consider a target with the implementation-defined ABI tags \type{simd128} and \type{simd256} where the \type{simd256} type requires an optional ISA extension on said target architecture.
    Also, the target does not support \type{long double} with either ABI tag.
    The implementation therefore defines
    \begin{itemize}
      \item \type{compatible<T>} as an alias for \type{simd128} for all arithmetic \type T, except \type{long double},
      \item and \type{compatible<long double>} as an alias for \type{scalar}.
    \end{itemize}
  }

  \pnum
  \type{datapar_abi::native<T>} is an alias for the ABI tag with the most efficient data parallel execution for the element type \type T that is supported on the target system.
  \wgNote{
    For target systems without ISA extensions, the \type{native<T>} and \type{compatible<T>} aliases will likely be the same.
    For target systems with ISA extensions, compiler flags may influence the \type{native<T>} alias while \type{compatible<T>} will be the same independent of such flags.
  }

  \wgExample{
      Consider a target with the implementation-defined ABI tags \type{simd128} and \type{simd256} where hardware support for \type{simd256} only exists for floating-point types.
    The implementation therefore defines \type{native<T>} as an alias for
    \begin{itemize}
      \item \type{simd256} if \type T is a floating-point type,
      \item and \type{simd128} otherwise.
    \end{itemize}
  }
\end{itemdescr}

\wgSubsubsection{\datapar type traits}{datapar.traits}
\begin{itemdecl}
template <class T> struct is_abi_tag;
\end{itemdecl}
\begin{itemdescr}
  \pnum The type \type{is_abi_tag<T>} is a \UnaryTypeTrait with a \BaseCharacteristic of \type{true_type} if \type T is the type of a standard or implementation-defined ABI tag, and \type{false_type} otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T> struct is_datapar;
\end{itemdecl}
\begin{itemdescr}
  \pnum The type \type{is_datapar<T>} is a \UnaryTypeTrait with a \BaseCharacteristic of \type{true_type} if \type T is an instance of the \datapar class template, and \type{false_type} otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T> struct is_mask;
\end{itemdecl}
\begin{itemdescr}
  \pnum The type \type{is_mask<T>} is a \UnaryTypeTrait with a \BaseCharacteristic of \type{true_type} if \type T is an instance of the \mask class template, and \type{false_type} otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, size_t N> struct abi_for_size { using type = implementation-defined; };
\end{itemdecl}
\begin{itemdescr}
  \pnum The member \type{type} shall be omitted if
  \begin{itemize}
    \item \type T is not supported by \datapar (see \ref{datapar.type requirements}),
    \item or if \fixedsizeN is not supported (see \ref{datapar.fixedsize.def}).
  \end{itemize}

  \pnum Otherwise, the member typedef \type{type} shall name an ABI tag type that satisfies
  \begin{itemize}
    \item \code{datapar_size_v<T, type> == N},
    \item \datapar[<T, type>] is supported for the current compilation target (see \ref{datapar.type requirements}),
    \item and \type{type} is not \fixedsizeN.
  \end{itemize}
  If such an ABI tag does not exist then \type{type} shall name \fixedsizeN.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi = datapar_abi::compatible<T>>
struct datapar_size : public integral_constant<size_t, implementation-defined> {};
\end{itemdecl}
\begin{itemdescr}
  \pnum\label{datapar_size}%
  \type{datapar_size<T, Abi>} shall have no member \code{value} if either
  \begin{itemize}
    \item \type T is cv-qualified,
    \item or \type T is \bool,
    \item or \type T is neither an integral nor floating-point type \parencite[(3.9.1)]{N4618},
    \item or \code{is_abi_tag_v<Abi>} is \false.
  \end{itemize}
  \wgNote{The rules are different from \ref{datapar.deleted}}

  \pnum
  Otherwise, the type \type{datapar_size<T, Abi>} is a \BinaryTypeTrait with a \BaseCharacteristic of \type{integral_constant<size_t, N>} with \code{N} equal to the number of elements in a \datapar[<T, Abi>] object.
  \wgNote{
    If \datapar[<T, Abi>] is not supported for the current compilation target, \type{datapar_size<T, Abi>::value} produces the value \datapar[<T, Abi>::size()] returns on a compilation target where it is supported.
  }

\end{itemdescr}

\begin{itemdecl}
template <class T, class U = typename T::value_type>
constexpr size_t memory_alignment = implementation-defined;
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires The template parameter \type T must be a valid instantiation of either the \datapar or the \mask class template.
  \pnum\requires The template parameter \type U must be a type supported by the load and store functions for \type T.
  \pnum The value of \code{memory_alignment<T, U>} identifies the alignment restrictions on pointers used for (converting) loads and stores for the given type \type T on arrays of type \type U.
\end{itemdescr}

\wgSubsubsection{Class templates \code{const_where_expression} and \code{where_expression}}{datapar.whereexpr}
\lstinputlisting[]{whereexpression.cpp}

\pnum The class templates \code{const_where_expression} and \code{where_expression<M, T>} combine a predicate and a value object to implement an interface that restricts assignments and/or operations on the value object to the elements selected via the predicate.

\pnum The first template argument \type M must be cv-unqualified \bool or a cv-unqualified \mask instantiation.

\pnum The second template argument \type T must be a cv-unqualified or \const qualified type \type{T'}.
If \type M is \bool, \type{T'} must be an arithmetic type.
Otherwise, \type{T'} must either be \type M or \type{M::datapar_type}.

\begin{itemdecl}
const M &mask;                           // exposition only
T &data;                                 // exposition only
const_where_expression(const M &, T &);  // exposition only
\end{itemdecl}
\begin{itemdescr}
  \pnum\wgNote{
  The implementation initializes a \type{where_expression<M, T>} object with a predicate of type \type M and a reference to a value object of type \type T.
  The predicate object and a const qualified value object may be copied by the constructor implementation.}

  \pnum\wgNote{
  The following declarations refer to the predicate as data member \code{mask} and to the value reference as data member \code{data}.
  }
\end{itemdescr}

\begin{itemdecl}
remove_const_t<T> operator-() const &&;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns If \type M is \bool, \code{-data} if \code{mask} is \true, \code{data} otherwise.
  If \type M is not \bool, returns an object with the $i$-th element initialized to \code{-data[i]} if \code{mask[i]} is \true and \code{data[i]} otherwise \foralli[M::].
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags>
[[nodiscard]] remove_const_t<T> memload(const U *mem, Flags) const &&;
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks If \type T is \bool or a \mask instantiation, the function only participates in overload resolution if \type U is \bool.
  Otherwise, the function only participates in overload resolution if \type U is an arithmetic type but not \bool.
  \pnum\returns If \type M is \bool, return \code{mem[0]} if \code{mask} equals \true and return \code{data} otherwise.
  If \type M is not \bool, return an object with the $i$-th element initialized to the $i$-th element of \code{data} if \code{mask[i]} is \false and \code{static_cast<T::value_type>(mem[i])} if \code{mask[i]} is \true \foralli[M::].

  \pnum\requires If \type M is not \bool, the largest $i$ where \code{mask[i]} is \true is less than the number of values pointed to by \code{mem}.
  \flagsRemarks{\type T, \type U}
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> void memstore(U *mem, Flags) const &&;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects If \type M is \bool, assign \code{data} to \code{mem[0]} unless \code{mask} is \false.
  \pnum\remarks If \type T is a (const qualified) \mask instantiation, the function only participates in overload resolution if \type U is \bool.
  If \type M is not \bool, copies the elements \code{data[i]} where \code{mask[i]} is \true as if \code{mem[i] = static_cast<U>(data[i])} \foralli[M::].

\begin{itemdecl}
template <class U> void operator=(U &&x);
template <class U> void operator+=(U &&x);
template <class U> void operator-=(U &&x);
template <class U> void operator*=(U &&x);
template <class U> void operator/=(U &&x);
template <class U> void operator%=(U &&x);
template <class U> void operator&=(U &&x);
template <class U> void operator|=(U &&x);
template <class U> void operator^=(U &&x);
template <class U> void operator<<=(U &&x);
template <class U> void operator>>=(U &&x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks Each of these operators only participate in overload resolution if the indicated operator can be applied to objects of type \type T.
  \pnum\effects
  If \type M is \bool, applies the indicated operator on \code{data} and \code{forward<U>(x)} unless \code{mask} is \false.
  If \type M is not \bool, applies the indicated operator on \code{data} and \code{forward<U>(x)} without modifying the elements \code{data[i]} where \code{mask[i]} is \false \foralli[M::].
  \pnum\remarks It is unspecified whether the arithmetic/bitwise operation, which is implied by a compound assignment operator, is executed on all elements or only on the ones written back.
\end{itemdescr}

\begin{itemdecl}
void operator++();
void operator++(int);
void operator--();
void operator--(int);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks Each of these operators only participate in overload resolution if the indicated operator can be applied to objects of type \type T.
  \pnum\effects
  If \type M is \bool, applies the indicated operator on \code{data} unless \code{mask} is \false.
  If \type M is not \bool, applies the indicated operator on \code{data} without modifying the elements \code{data[i]} where \code{mask[i]} is \false \foralli[M::].
  \wgNote{It is unspecified whether the inc-/decrement operation is executed on all elements or only on the ones written back.}
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> void memload(const U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks If \type T is \bool or a \mask instantiation, the function only participates in overload resolution if \type U is \bool.
  \pnum\effects If \type M is \bool, assign \code{mem[0]} to \code{data} unless \code{mask} is \false.
  If \type M is not \bool, replace the elements of \code{data} where \code{mask[i]} is \true such that the $i$-th element is assigned with \code{static_cast<T::value_type>(mem[i])} \foralli[M::].

  \pnum\requires If \type M is not \bool, the largest $i$ where \code{mask[i]} is \true is less than the number of values pointed to by \code{mem}.
  \flagsRemarks{\type T, \type U}
\end{itemdescr}

  \pnum\requires If \type M is not \bool, the largest $i$ where \code{mask[i]} is \true is less than the number of values pointed to by \code{mem}.
  \flagsRemarks{\type remove_const_t<T>, \type U}
\end{itemdescr}

% vim: tw=0
