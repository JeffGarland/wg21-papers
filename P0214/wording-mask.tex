\wgSubsection{Class template \type{simd_mask}}{simd_mask}
\wgSubsubsection{Class template \mask overview}{simd_mask.overview}
\lstinputlisting[]{mask.cpp}

\pnum The class template \mask[<T, Abi>] is a one-dimensional smart array of booleans.
The number of elements in the array is a constant expression, equal to the number of elements in \simd[<T, Abi>].

\simdTypeRequirements{simd_mask}

\pnum Default initialization performs no initialization of the elements; value-initialization initializes each element with \code{bool()}.
\wgNote{Thus, default initialization leaves the elements in an indeterminate state.}

\begin{itemdecl}
static constexpr size_type size() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns the number of boolean elements stored in objects of the given \mask[<T, Abi>] type.
\end{itemdescr}

\pnum\begin{noteEnv}Implementations are encouraged to enable \code{static_cast}ing from/to (an) implementation-defined SIMD mask type(s).
This would add one or more of the following declarations to class \mask:
\begin{itemdecl}
explicit operator implementation-defined() const;
explicit simd(const implementation-defined& init);
\end{itemdecl}
\end{noteEnv}

\wgSubsubsection{\mask constructors}{simd_mask.ctor}
\begin{itemdecl}
explicit simd_mask(value_type) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object with each element initialized to the value of the argument.
\end{itemdescr}

\begin{itemdecl}
template <class U> simd_mask(const simd_mask<U, simd_abi::fixed_size<size()>>& x) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks This constructor shall not participate in overload resolution unless
    \type{abi_type} equals \fixedsizescoped{}\code{<size()>}.
  \pnum\effects Constructs an object of type \mask where the $i$-th element equals \code{x[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class Flags> simd_mask(const value_type *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{mem[i]} \foralli.
  \pnum\requires \code{size()} is less than or equal to the number of values pointed to by \code{mem}.
  \flagsRemarks{\mask{}}
\end{itemdescr}

\wgSubsubsection{\mask load function}{simd_mask.load}
\begin{itemdecl}
template <class Flags> void copy_from(const value_type *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces the elements of the \mask object such that the $i$-th element is assigned with \code{mem[i]} \foralli.
  \pnum\requires \code{size()} is less than or equal to the number of values pointed to by \code{mem}.
  \flagsRemarks{\mask{}}
\end{itemdescr}

\wgSubsubsection{\mask store function}{simd_mask.store}
\begin{itemdecl}
template <class Flags> void copy_to(value_type *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies all \mask elements as if \code{mem[i] = operator[](i)} \foralli.
  \pnum\requires \code{size()} is less than or equal to the number of values pointed to by \code{mem}.
  \flagsRemarks{\mask{}}
\end{itemdescr}

\wgSubsubsection{\mask{} subscript operators}{simd_mask.subscr}
\begin{itemdecl}
reference operator[](size_type i);
\end{itemdecl}
\begin{itemdescr}
  \simdElementReference{\mask{}}
\end{itemdescr}

\begin{itemdecl}
value_type operator[](size_type i) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires The value of \code{i} is less than \code{size()}.

  \pnum\returns A copy of the $i$-th element.

  \pnum\throws Nothing.
\end{itemdescr}

\wgSubsubsection{\mask unary operators}{simd_mask.unary}
\begin{itemdecl}
mask operator!() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \mask object with the $i$-th element set to the logical negation \foralli.
\end{itemdescr}

\wgSubsection{\type{simd_mask} non-member operations}{simd_mask.nonmembers}

\wgSubsubsection{\mask binary operators}{simd_mask.binary}
\begin{itemdecl}
friend simd_mask operator&&(const simd_mask&, const simd_mask&) noexcept;
friend simd_mask operator||(const simd_mask&, const simd_mask&) noexcept;
friend simd_mask operator& (const simd_mask&, const simd_mask&) noexcept;
friend simd_mask operator| (const simd_mask&, const simd_mask&) noexcept;
friend simd_mask operator^ (const simd_mask&, const simd_mask&) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \mask object initialized with the results of the component-wise application of the indicated operator.
\end{itemdescr}

\wgSubsubsection{\mask compound assignment}{simd_mask.cassign}
\begin{itemdecl}
friend simd_mask& operator&=(simd_mask&, const simd_mask&) noexcept;
friend simd_mask& operator|=(simd_mask&, const simd_mask&) noexcept;
friend simd_mask& operator^=(simd_mask&, const simd_mask&) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Each of these operators performs the indicated operator component-wise on each of the corresponding elements of the arguments.
  \pnum\returns A reference to the first argument.
\end{itemdescr}

\wgSubsubsection{\mask compares}{simd_mask.comparison}
\begin{itemdecl}
friend simd_mask operator==(const simd_mask&, const simd_mask&) noexcept;
friend simd_mask operator!=(const simd_mask&, const simd_mask&) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \mask object initialized with the results of the component-wise application of the indicated operator.
\end{itemdescr}

\wgSubsubsection{\mask reductions}{simd_mask.reductions}
\begin{itemdecl}
template <class T, class Abi> bool  all_of(simd_mask<T, Abi>) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if all boolean elements in the function argument equal \true, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> bool  any_of(simd_mask<T, Abi>) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if at least one boolean element in the function argument equals \true, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> bool none_of(simd_mask<T, Abi>) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if none of the boolean element in the function argument equals \true, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> bool some_of(simd_mask<T, Abi>) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if at least one of the boolean elements in the function argument equals \true and at least one of the boolean elements in the function argument equals \false, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> int popcount(simd_mask<T, Abi>) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The number of boolean elements that are \true.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> int find_first_set(simd_mask<T, Abi> m);
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires \code{any_of(m)} returns \true
  \pnum\returns The lowest element index \code i where \code{m[i] == true}.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> int find_last_set(simd_mask<T, Abi> m);
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires \code{any_of(m)} returns \true
  \pnum\returns The highest element index \code i where \code{m[i] == true}.
\end{itemdescr}

\begin{itemdecl}
bool  all_of(implementation-defined) noexcept;
bool  any_of(implementation-defined) noexcept;
bool none_of(implementation-defined) noexcept;
bool some_of(implementation-defined) noexcept;
int popcount(implementation-defined) noexcept;
int find_first_set(implementation-defined) noexcept;
int find_last_set(implementation-defined) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks The functions shall not participate in overload resolution unless the argument is of type \bool.
  \pnum\returns \code{all_of} and \code{any_of} return their arguments; \code{none_of} returns the negation of its argument; \code{some_of} returns \false; \code{popcount} returns the integral representation of its argument; \code{find_first_set} and \code{find_last_set} return 0.
\end{itemdescr}

\wgSubsubsection{Masked assigment}{simd_mask.where}
\begin{itemdecl}
template <class T, class A>
where_expression<simd_mask<T, A>, simd<T, A>> where(
    const typename simd<T, A>::mask_type& k, simd<T, A>& v) noexcept;
template <class T, class A>
const where_expression<simd_mask<T, A>, const simd<T, A>> where(
    const typename simd<T, A>::mask_type& k, const simd<T, A>& v) noexcept;

template <class T, class A>
where_expression<simd_mask<T, A>, simd_mask<T, A>> where(const remove_const_t<simd_mask<T, A>>& k,
                                               simd_mask<T, A>& v) noexcept;
template <class T, class A>
const where_expression<simd_mask<T, A>, const simd_mask<T, A>> where(
    const remove_const_t<simd_mask<T, A>>& k, const simd_mask<T, A>& v) noexcept;
\end{itemdecl}
\comment{\code{remove_const} is only used in place of a missing \code{template <class T> struct id \{ using type = T; \};} for inhibiting type deduction.}
\begin{itemdescr}
  \pnum\returns An object of type \type{where_expression} (see \ref{sec:simd.whereexpr}) initialized with the predicate \code k and the value reference \code v.
\end{itemdescr}

\begin{itemdecl}
template <class T> where_expression<bool, T> where(implementation-defined k, T& v) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks The function shall not participate in overload resolution unless
  \begin{itemize}
    \item \type T is neither a \simd nor a \mask instantiation, and
    \item the first argument is of type \bool.
  \end{itemize}
  \pnum\returns An object of type \type{where_expression} (see \ref{sec:simd.whereexpr}) initialized with the predicate \code k and the value reference \code v.
\end{itemdescr}

% vim: tw=0 spell sw=2
