\wgSubsection{Class template \type{mask}}{mask}
\wgSubsubsection{Class template \mask overview}{mask.overview}
\lstinputlisting[]{mask.cpp}

\pnum The class template \mask[<T, Abi>] is a one-dimensional smart array of booleans.
The number of elements in the array is determined at compile time, equal to the number of elements in \datapar[<T, Abi>].

\pnum The first template argument \type T must be an integral or floating-point fundamental type.
The type \bool is not allowed.

\pnum The second template argument \type{Abi} must be a tag type from the \code{datapar_abi} namespace.

\begin{itemdecl}
static constexpr size_type size();
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns the number of boolean elements stored in objects of the given \mask[<T, Abi>] type.
\end{itemdescr}

\pnum\realnote Implementations are encouraged to enable \code{static_cast}ing from/to (an) implementation-defined SIMD mask type(s).
This would add one or more of the following declarations to class \mask:
\begin{itemdecl}
explicit operator implementation_defined() const;
explicit datapar(const implementation_defined &init);
\end{itemdecl}

\wgSubsubsection{\mask constructors}{mask.ctor}
\begin{itemdecl}
mask() = default;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object with all elements initialized to \code{bool()}.
  \wgNote{This zero-initializes the object.}
\end{itemdescr}

\begin{itemdecl}
explicit mask(value_type);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object with each element initialized to the value of the argument.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Abi2> mask(mask<U, Abi2> x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks This constructor shall not participate in overload resolution unless
    \datapar[<U, Abi2>] is implicitly convertible to \datapar[<T, Abi>].
  \pnum\effects Constructs an object of type \mask where the $i$-th element equals \code{x[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class Flags> mask(const value_type *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{mem[i]} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\mask{}>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class Flags> mask(const value_type *mem, mask k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{k[i] ? mem[i] : false} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\mask{}>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\mask load function}{mask.load}
\begin{itemdecl}
template <class Flags> void copy_from(const value_type *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces the elements of the \mask object such that the $i$-th element is assigned with \code{mem[i]} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\mask{}>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class Flags> void copy_from(const value_type *mem, mask k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces all elements of the \mask object where $k[i]$ is \true such that the $i$-th element is assigned with \code{mem[i]} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\mask{}>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\mask store functions}{mask.store}
\begin{itemdecl}
template <class Flags> void copy_to(value_type *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies all \mask elements as if \code{mem[i] = operator[](i)} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by \code{mem}, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\mask{}>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class Flags> void copy_to(value_type *mem, mask k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies each \mask element $i$ where \code{k[i]} is \true as if \code{mem[i] = operator[](i)} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by \code{mem}, the behavior is undefined.
  \wgNote{
    Masked stores only write to the bytes in memory selected by the \code k argument.
    This prohibits implementations that load, blend, and store the complete vector.
  }
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\mask{}>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\mask{} subscript operators}{mask.subscr}
\begin{itemdecl}
reference operator[](size_type i);
\end{itemdecl}
\begin{itemdescr}
  \dataparElementReference
\end{itemdescr}

\begin{itemdecl}
value_type operator[](size_type) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A copy of the $i$-th element.
\end{itemdescr}

\wgSubsubsection{\mask unary operators}{mask.unary}
\begin{itemdecl}
mask operator!() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A mask object with the $i$-th element set to the logical negation \foralli.
\end{itemdescr}

\wgSubsection{\type{mask} non-member operations}{mask.nonmembers}

\wgSubsubsection{\mask binary operators}{mask.binary}
\begin{itemdecl}
friend mask operator&&(const mask &, const mask &);
friend mask operator||(const mask &, const mask &);
friend mask operator& (const mask &, const mask &);
friend mask operator| (const mask &, const mask &);
friend mask operator^ (const mask &, const mask &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \mask object initialized with the results of the component-wise application of the indicated operator.
\end{itemdescr}

\wgSubsubsection{\mask compares}{mask.comparison}
\begin{itemdecl}
friend bool operator==(const mask &, const mask &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if all boolean elements of the first argument equal the corresponding element of the second argument.
  It returns \false otherwise.
\end{itemdescr}

\begin{itemdecl}
friend bool operator!=(const mask &, const mask &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \code{!operator==(a, b)}.
\end{itemdescr}

\wgSubsubsection{\mask reductions}{mask.reductions}
\begin{itemdecl}
template <class T, class Abi> bool  all_of(mask<T, Abi>);
constexpr bool  all_of(bool);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if all boolean elements in the function argument equal \true, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> bool  any_of(mask<T, Abi>);
constexpr bool  any_of(bool);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if at least one boolean element in the function argument equals \true, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> bool none_of(mask<T, Abi>);
constexpr bool none_of(bool);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if none of the boolean element in the function argument equals \true, \false otherwise.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> bool some_of(mask<T, Abi>);
constexpr bool some_of(bool);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \true if at least one of the boolean elements in the function argument equals \true and at least one of the boolean elements in the function argument equals \false, \false otherwise.
  \pnum\realnote \code{some_of(bool)} unconditionally returns \false.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> int popcount(mask<T, Abi>);
constexpr int popcount(bool);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The number of boolean elements that are \true.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> int find_first_set(mask<T, Abi> m);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The lowest element index \code i where \code{m[i] == true}.
  \pnum\remarks If \code{none_of(m) == true} the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class T, class Abi> int find_last_set(mask<T, Abi> m);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The highest element index \code i where \code{m[i] == true}.
  \pnum\remarks If \code{none_of(m) == true} the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
constexpr int find_first_set(bool);
constexpr int find_last_set(bool);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns 0 if the argument is \true.
\end{itemdescr}

\wgSubsubsection{Masked assigment}{mask.where}
\begin{itemdecl}
template <class T, class A>
where_expression<const mask<T, A> &, datapar<T, A>> where(
    const typename datapar<T, A>::mask_type &m, datapar<T, A> &v);
template <class T, class A>
const where_expression<const mask<T, A> &, const datapar<T, A>> where(
    const typename datapar<T, A>::mask_type &m, const datapar<T, A> &v);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A temporary object with the following properties:
  \begin{itemize}
    \item The object is not \textit{CopyConstructible}.
    \item Assignment and compound assignment operators only participate in overload resolution if the corresponding operator for \datapar[<T, A>] is usable.
    \item \effects Assignment and compound assignment implement the same semantics as the corresponding operator for \datapar[<T, A>] with the exception that elements of \code v stay unmodified if the corresponding boolean element in \code m is \false.
    \item The assignment and compound assignment operators return \void.
  \end{itemize}
  \pnum\realnote The \const overload is only useful for functions that should be applied to a masked \datapar input.
\end{itemdescr}

\begin{itemdecl}
template <class T> where_expression<bool, T> where(bool k, T &d);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks The function only participates in overload resolution if \type T is not a \datapar instantiation.
  \pnum\returns A temporary object with the following properties:
  \begin{itemize}
    \item The object is not \textit{CopyConstructible}.
    \item Assignment and compound assignment operators only participate in overload resolution if the corresponding operator for \type T is usable.
    \item \effects If the first argument is \false, the assignment operators do nothing.
      If the first argument is \true, the assignment operators forward to the corresponding builtin assignment operator.
    \item The assignment and compound assignment operators return \void.
  \end{itemize}
\end{itemdescr}

% vim: tw=0 spell sw=2
