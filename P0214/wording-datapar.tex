\wgSubsection{Class template \type{datapar}}{datapar}
\wgSubsubsection{Class template \datapar overview}{datapar.overview}
\lstinputlisting[]{datapar.cpp}

\pnum The class template \datapar{}\type{<T, Abi>} is a one-dimensional smart array.
In contrast to \type{valarray} (26.6), the number of elements in the array is determined at compile time, according to the \type{Abi} template parameter.

\pnum The first template argument \type T must be an integral or floating-point fundamental type.
The type \bool is not allowed.

\pnum The second template argument \type{Abi} must be a tag type from the \code{datapar_abi} namespace.

\begin{itemdecl}
static constexpr size_type size();
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns the number of elements stored in objects of the given \datapar[<T, Abi>] type.
\end{itemdescr}

\pnum\realnote Implementations are encouraged to enable \code{static_cast}ing from/to (an) implementation-defined SIMD type(s).
This would add one or more of the following declarations to class \datapar:
\begin{itemdecl}
explicit operator implementation_defined() const;
explicit datapar(const implementation_defined &init);
\end{itemdecl}

\wgSubsubsection{\datapar constructors}{datapar.ctor}
\begin{itemdecl}
datapar() = default;
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \effects
  Constructs an object with all elements initialized to \code{T()}.
  \wgNote{This zero-initializes the object.}
\end{itemdescr}

\begin{itemdecl}
datapar(value_type);
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \effects
  Constructs an object with each element initialized to the value of the argument.
\end{itemdescr}

\comment{Should I add a generator ctor, taking a lambda to initialize the elements?}

\begin{itemdecl}
template <class U, class Abi2> datapar(datapar<U, Abi2> x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks This constructor shall not participate in overload resolution unless either
  \begin{itemize}
    \item \type{Abi} and \type{Abi2} are equal and
      \type U and \type T are different integral types and
      \code{make_signed<U>::type} equals \code{make_signed<T>::type}, or
    \item at least one of \type{Abi} or \type{Abi2} is an instantiation of \fixedsizescoped and \code{size() == x.size()} and \type U is implicitly convertible to \type T.
  \end{itemize}
  \pnum\effects Constructs an object where the $i$-th element equals \code{static_cast<T>(x[i])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> datapar(const U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{static_cast<T>(mem[i])} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> datapar(const U *mem, mask_type k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{k[i] ? static_cast<T>(mem[i]) : 0} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\datapar load functions}{datapar.load}
\begin{itemdecl}
template <class U, class Flags> void copy_from(const U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces the elements of the \datapar object such that the $i$-th element is assigned with \code{static_cast<T>(mem[i])} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> void copy_from(const U *mem, mask_type k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces all elements of the \datapar object where $k[i]$ is \true such that the $i$-th element is assigned with \code{static_cast<T>(mem[i])} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \wgNote{
    Masked loads only access the bytes in memory selected by the \code k argument.
    This prohibits implementations that load the complete vector before blending with the previous values.
  }
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\datapar store functions}{datapar.store}
\begin{itemdecl}
template <class U, class Flags> void copy_to(U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies all \datapar elements as if \code{mem[i] = static_cast<U>(operator[](i))} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by \code{mem}, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> void copy_to(U *mem, mask_type k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies each \datapar element $i$ where \code{k[i]} is \true as if \code{mem[i] = static_cast<U>(operator[](i))} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by \code{mem}, the behavior is undefined.
  \wgNote{
    Masked stores only write to the bytes in memory selected by the \code k argument.
    This prohibits implementations that load, blend, and store the complete vector.
  }
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\datapar subscript operators}{datapar.subscr}
\newcommand{\dataparElementReference}{
  \pnum\returns A temporary object with the following properties:
  \begin{itemize}
    \item \remarks The object is neither \textit{DefaultConstructible}, \textit{CopyConstructible}, \textit{MoveConstructible}, \textit{CopyAssignable}, nor \textit{MoveAssignable}.

    \item \remarks Assignment, compound assignment, increment, and decrement operators only participate in overload resolution if
      called in rvalue context and the corresponding operator of type \valuetype is usable.

    \item \effects The assignment, compound assignment, increment, and decrement operators execute the indicated operation on the $i$-th element in the \datapar object.

    \item \effects Conversion to \valuetype returns a copy of the $i$-th element.
  \end{itemize}
}
\begin{itemdecl}
reference operator[](size_type i);
\end{itemdecl}
\begin{itemdescr}
  \dataparElementReference
\end{itemdescr}

\begin{itemdecl}
value_type operator[](size_type) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A copy of the $i$-th element.
\end{itemdescr}

\wgSubsubsection{\datapar unary operators}{datapar.unary}
\begin{itemdecl}
datapar &operator++();
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Increments every element of \code{*this} by one.
  \pnum\returns An lvalue reference to \code{*this} after incrementing.
  \pnum\remarks Overflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
datapar operator++(int);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Increments every element of \code{*this} by one.
  \pnum\returns A copy of \code{*this} before incrementing.
  \pnum\remarks Overflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
datapar &operator--();
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Decrements every element of \code{*this} by one.
  \pnum\returns An lvalue reference to \code{*this} after decrementing.
  \pnum\remarks Underflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
datapar operator--(int);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Decrements every element of \code{*this} by one.
  \pnum\returns A copy of \code{*this} before decrementing.
  \pnum\remarks Underflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
mask_type operator!() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A mask object with the $i$-th element set to \code{!operator[](i)} \foralli.
\end{itemdescr}

\begin{itemdecl}
datapar operator~() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires The first template argument \type T to \datapar must be an integral type.
  \pnum\returns A \datapar object where each bit is the inverse of the corresponding bit in \code{*this}.
  \pnum\remarks \datapar{}\code{::operator\textasciitilde{}()} shall not participate in overload resolution if \type T is a floating-point type.
\end{itemdescr}

\begin{itemdecl}
datapar operator+() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum \returns A copy of \code{*this}
\end{itemdescr}

\begin{itemdecl}
datapar operator-() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \datapar object where the $i$-th element is initialized to \code{-operator[](i)} \foralli.
\end{itemdescr}

\wgSubsubsection{\datapar reductions}{datapar.redu}
\comment{These functions are now redundant because of non-member \code{reduce}.
I prefer to keep these as shorthands, though.}
\begin{itemdecl}
value_type sum() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The sum of all the elements stored in the \datapar object.
    The order of summation is arbitrary.
\end{itemdescr}

\begin{itemdecl}
value_type sum(mask_type) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The sum of all the elements stored in the \datapar object where the corresponding element in the first argument is \true.
  The order of summation is arbitrary.
  If all elements in the first argument are \false, then the return value is 0.
\end{itemdescr}

\begin{itemdecl}
value_type product() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The product of all the elements stored in the \datapar object.
    The order of multiplication is arbitrary.
\end{itemdescr}

\begin{itemdecl}
value_type product(mask_type) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The product of all the elements stored in the \datapar object where the corresponding element in the first argument is \true.
  The order of multiplication is arbitrary.
  If all elements in the first argument are \false, then the return value is 1.
\end{itemdescr}

\begin{itemdecl}
value_type min() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element $j$ for which \code{operator[](j) <= operator[](i)} \foralli.
\end{itemdescr}

\begin{itemdecl}
value_type min(mask_type k) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element $j$ for which \code{k[j] == true} and \code{operator[](j) <= operator[](i) || !k[i]} \foralli.
  \pnum\remarks If all elements in \code k are \false, the return value is undefined.%
  \comment{Alternatively, it could return \code{numeric_limits<value_type>::min()}.}
\end{itemdescr}

\begin{itemdecl}
value_type max() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element $j$ for which \code{operator[](j) >= operator[](i)} \foralli.
\end{itemdescr}

\begin{itemdecl}
value_type max(mask_type k) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element $j$ for which \code{k[j] == true} and \code{operator[](j) >= operator[](i) || !k[i]} \foralli.
  \pnum\remarks If all elements in \code k are \false, the return value is undefined.%
  \comment{Alternatively, it could return \code{numeric_limits<value_type>::max()}.}
\end{itemdescr}

\wgSubsection{\type{datapar} non-member operations}{datapar.nonmembers}

\wgSubsubsection{\datapar binary operators}{datapar.binary}
\begin{itemdecl}
template <class L, class R> using datapar_return_type = ...;  // exposition only
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator+ (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator- (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator* (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator/ (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator% (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator& (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator| (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator^ (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator<<(datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator>>(datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator+ (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator- (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator* (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator/ (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator% (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator& (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator| (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator^ (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator<<(const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
datapar_return_type<datapar<T, Abi>, U> operator>>(const U &, datapar<T, Abi>);
\end{itemdecl}
\begin{itemdescr}
  \newcommand\dataparreturntype{\type{datapar_return_type<datapar<T, Abi>, U>}\xspace}
  \pnum\remarks\label{unusual conversions}
  The return type of these operators (\dataparreturntype) shall be deduced according to the following rules:%
  \comment{See \url{https://github.com/VcDevel/Vc/blob/191e13b2268c630d8e146157903b97181f9a49bd/tests/datapar.cpp\#L435} for a test of an implementation of these rules.}
  \begin{itemize}
    \item Let \common{A}{B} identify the type:
      \comment{\textit{unusual arithmetic conversions} ;-)}
      \begin{itemize}
        \item \type A if \type A equals \type B.
        \item Otherwise, \type A if \type B is not a fundamental arithmetic type.
        \item Otherwise, \type B if \type A is not a fundamental arithmetic type.
        \item Otherwise, \code{decltype(A() + B())} if any of the types \type A or \type B is a floating-point type.
        \item Otherwise, \type A if \code{sizeof(A) > sizeof(B)}.
        \item Otherwise, \type B if \code{sizeof(A) < sizeof(B)}.
        \item Otherwise, \type C shall identify the type with greater integer conversion rank of the types \type A and \type B and:
          \begin{itemize}
            \item \type C is used if \code{is_signed_v<A> == is_signed_v<B>}, and
            \item \code{make_unsigned_t<C>} otherwise.
          \end{itemize}
      \end{itemize}
    \item Let \commonabi{V0}{V1}{T} identify the type:
      % Consider:
      % if datapar<int>::size() == datapar<float>::size() then the following may not happen:
      % datapar<int> + datapar<float, fixed_size> -> datapar<float>
      % because datapar<int> is not convertible to datapar<float>
      %
      % OTOH, it would be nice to get:
      % datapar<float> + datapar<int, fixed_size> -> datapar<float>, because that type was one of the input types
      % datapar<long> + datapar<unsigned int, fixed_size> -> datapar<unsigned long
      % datapar<float, fixed_size> + datapar<double, fixed_size> -> datapar<double, fixed_size> (i.e. never native)
      \begin{itemize}
        \item \type{V0::abi_type} if \type{V0::abi_type} equals \type{V1::abi_type}. % the remaining cases therefore only cover one native ABI and one fixed_size<N>
        \item Otherwise, \code{abi_for_size_t<T, V0::size()>} if both \type{V0} and \type{V1} are implicitly convertible to \datapar[<\type T, abi_for_size_t<T, V0::size()>>].
        \item Otherwise, \fixedsizescoped{}\code{<\type{V0}::size()>}.
      \end{itemize}
    \item If \code{is_datapar_v<U> == true}
      then the return type is \datapar[<\common{T}{U::value_type}, \commonabi{datapar<T, Abi>}{U}{\common{T}{U::value_type}}>].
      \wgNote{
        This rule also matches if \code{datapar_size_v<T, Abi> != U::size()}.
        The overload resolution participation condition in the next paragraph discards the operator.
      }
    \item Otherwise, if \type T is integral and \type U is \intt
      the return type shall be \datapar{}\type{<T, Abi>}.%
      \comment{i.e. \code{\datapar{}<signed char>() + int() -> \datapar{}<signed char>}, however \code{\datapar{}<signed char>() + short() -> \datapar{}<short, fixed_size<datapar_size_v<signed char>>>}}
    \item Otherwise, if \type T is integral and \type U is \uint
      the return type shall be \datapar{}\code{<make_unsigned_t<T>, Abi>}.%
      \comment{i.e. \code{\datapar[<signed char>]() + uint() -> \datapar[<unsigned char>]}, however \code{\datapar[<signed char>]() + ushort() -> \datapar[<ushort, fixed_size<datapar_size_v<signed char>>>]}}
    \item Otherwise, if \type U is a fundamental arithmetic type
      then the return type shall be \datapar[<\common{T}{U}, \commonabi{datapar<T, Abi>}{datapar<U, \fixedsizescoped{}<datapar_size_v<T, Abi>>>}{\common{T}{U}}>].
    \item Otherwise, if \type U is convertible to \intt
      then the return type shall be \datapar[<\common{T}{U}, \commonabi{datapar<T, Abi>}{datapar<int, \fixedsizescoped{}<datapar_size_v<T, Abi>>>}{\common{T}{U}}>].
    \item Otherwise, if \type U is implicitly convertible to \datapar{}\type{<V, A>}, where \type V and \type A are determined according to standard template type deduction,
      then the return type shall be \datapar[<\common{T}{V}, \commonabi{datapar<T, Abi>}{datapar<V, A>}{\common{T}{V}}>].
    \item Otherwise, if \type U is implicitly convertible to \datapar{}\type{<T, Abi>},
      the return type shall be \datapar{}\type{<T, Abi>}.
    \item Otherwise the operator does not participate in overload resolution.%
      \comment{
        This seems a strange place to put this.
        Alternatively, modify the above rule to unconditionally use \datapar{}\type{<T, Abi>}.
        The paragraph below would lead to the same effect.
      }
  \end{itemize}

  \pnum\remarks Each of these operators only participate in overload resolution if all of the following hold:
  \begin{itemize}
    \item The indicated operator can be applied to objects of type \dataparreturntype{}\code{::}\type{value_type}.
    \item \datapar{}\type{<T, Abi>} is implicitly convertible to \dataparreturntype.
    \item \type U is implicitly convertible to \dataparreturntype.
  \end{itemize}
  \comment{
    I think this allows \code{datapar<float, fixed_size<4>>() + double()} and returns \datapar[<double, fixed_size<4>>].
    I also think that's what we want.
  }

  \pnum\remarks The operators with \type{const U \&} as first parameter shall not participate in overload resolution if \code{is_datapar_v<U> == true}.

  \pnum\returns A \datapar object initialized with the results of the component-wise application of the indicated operator after both operands have been converted to the return type.
\end{itemdescr}

\wgSubsubsection{\datapar compound assignment}{datapar.cassign}
\begin{itemdecl}
template <class T, class Abi, class U> datapar<T, Abi> &operator+= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator-= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator*= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator/= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator%= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator&= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator|= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator^= (datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator<<=(datapar<T, Abi> &, const U &);
template <class T, class Abi, class U> datapar<T, Abi> &operator>>=(datapar<T, Abi> &, const U &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks Each of these operators only participates in overload resolution if all of the following hold:
  \begin{itemize}
    \item The indicated operator can be applied to objects of type \type{datapar_return_type<datapar<T, Abi>, U>::value_type}.
    \item \datapar{}\type{<T, Abi>} is implicitly convertible to \type{datapar_return_type<datapar<T, Abi>, U>}.
    \item \type U is implicitly convertible to \type{datapar_return_type<datapar<T, Abi>, U>}.
    \item \type{datapar_return_type<datapar<T, Abi>, U>} is implicitly convertible to \datapar{}\type{<T, Abi>}.
  \end{itemize}
  \pnum\effects Each of these operators performs the indicated operation component-wise on each of the elements of the first argument and the corresponding element of the second argument after conversion to \datapar{}\code{<T, Abi>}.
  \pnum\returns A reference to the first argument.
\end{itemdescr}

\wgSubsubsection{\datapar logical operators}{datapar.logical}
\realnote The omission of logical operators is deliberate.

\wgSubsubsection{\datapar compare operators}{datapar.comparison}
\begin{itemdecl}
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator==(datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator!=(datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator>=(datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator<=(datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator> (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator< (datapar<T, Abi>, const U &);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator==(const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator!=(const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator>=(const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator<=(const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator> (const U &, datapar<T, Abi>);
template <class T, class Abi, class U>
typename datapar_return_type<datapar<T, Abi>, U>::mask_type operator< (const U &, datapar<T, Abi>);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks The return type of these operators shall be the \type{mask_type} member type of the type deduced according to the rules defined in [datapar.binary].

  \pnum\remarks Each of these operators only participates in overload resolution if all of the following hold:
  \begin{itemize}
    \item \datapar{}\type{<T, Abi>} is implicitly convertible to \type{datapar_return_type<datapar<T, Abi>, U>}.
    \item \type U is implicitly convertible to \type{datapar_return_type<datapar<T, Abi>, U>}.
  \end{itemize}

  \pnum\remarks The operators with \type{const U \&} as first parameter shall not participate in overload resolution if \code{is_datapar_v<U> == true}.

  \pnum\returns A \mask object initialized with the results of the component-wise application of the indicated operator after both operands have been converted to \type{datapar_return_type<datapar<T, Abi>, U>}.
\end{itemdescr}

\wgSubsubsection{\datapar non-member reductions}{datapar.reductions}
\begin{itemdecl}
template <class BinaryOperation = std::plus<>, class T, class Abi>
T reduce(const datapar<T, Abi> &x, BinaryOperation binary_op = BinaryOperation());
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \code{\textit{GENERALIZED_SUM}(binary_op, x.data[i], \ldots)} \foralli.
  \pnum\requires \code{binary_op} shall be callable on arguments of type \type T and arguments of type \datapar[<T, A1>], where \type{A1} may be different to \type{Abi}.
  \pnum\realnote This overload of \code{reduce} does not require an initial value because \code x is guaranteed to be non-empty.
\end{itemdescr}

\begin{itemdecl}
template <class BinaryOperation = std::plus<>, class M, class T, class Abi>
U reduce(const where_expression<M, datapar<T, Abi>> &x, T init,
         BinaryOperation binary_op = BinaryOperation());
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \code{\textit{GENERALIZED_SUM}(binary_op, init, x.data[i], \ldots)} \forallmaskedi{x.mask}.
  \pnum\requires \code{binary_op} shall be callable on arguments of type \type T and arguments of type \datapar[<T, A1>], where \type{A1} may be different to \type{Abi}.
  \pnum\realnote This overload of \code{reduce} requires an initial value because \code x may be empty.
\end{itemdescr}

\wgSubsubsection{\datapar casts}{datapar.casts}
\begin{itemdecl}
template <class T, class U, class... Us>
conditional_t<(T::size() == (U::size() + Us::size()...)), T,
            array<T, (U::size() + Us::size()...) / T::size()>> datapar_cast(U, Us...);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks The \code{datapar_cast} function only participates in overload resolution if all of the following hold:
  \begin{itemize}
    \item \code{is_datapar_v<T>}
    \item \code{is_datapar_v<U>}
    \item All types in the template parameter pack \type{Us} are equal to \type U.
    \item \code{U::size() + Us::size()...} is an integral multiple of \code{T::size()}.
  \end{itemize}

  \pnum\returns A \datapar object initialized with the converted values as one object of \type T or an array of \type T.
  All scalar elements \code{x\textsubscript{i}} of the function argument(s) are converted as if
  \code{y\textsubscript{i} = static_cast<typename T::value_type>(x\textsubscript{i})} is executed.
  The resulting \code{y\textsubscript{i}} intialize the return object(s) of type \type T.
  \wgNote{%
    For \code{T::size() == 2 * U::size()} the following holds:
    \code{datapar_cast<T>(x0, x1)[i] == static_cast<typename T::value_type>(array<U, 2>\{x0, x1\}[i / U::size()][i \% U::size()])}.
    For \code{2 * T::size() == U::size()} the following holds:
    \code{datapar_cast<T>(x)[i][j] == static_cast<typename T::value_type>(x[i * T\MayBreak::size() + j])}.
  }
\end{itemdescr}

\wgSubsubsection{\datapar math library}{datapar.math}
\lstinputlisting[]{math.cpp}

\pnum Each listed function concurrently applies the indicated mathematical function component-wise.
The results per component are not required to be binary equal to the application of the function which is overloaded for the element type.
\comment{Neither the C nor the \CC{} standard say anything about expected error/precision.
It seems returning 0 from all functions is a conforming implementation --- just bad QoI.}

\pnum If \code{abs()} is called with an argument of type \datapar[<X, Abi>] for which \code{is_unsigned<X>::value} is \true, the program is ill-formed.

% vim: tw=0 spell sw=2
