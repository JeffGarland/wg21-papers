\newcommand\wgTitle{Clarify intent of P1841 numeric traits}
\newcommand\wgName{Matthias Kretz <m.kretz@gsi.de>\\Jonathan Wakely <cxx@kayari.org>}
\newcommand\wgDocumentNumber{P2551R1}
\newcommand\wgGroup{LEWG}
\newcommand\wgTarget{\CC{}23}
%\newcommand\wgAcknowledgements{ }

\usepackage{mymacros}
\usepackage{wg21}
\usepackage{changelog}
\usepackage{underscore}

\addbibresource{extra.bib}

\newcommand\wglink[1]{\href{https://wg21.link/#1}{#1}}

\begin{document}
\selectlanguage{american}
\begin{wgTitlepage}
  A list of design-related questions after implementation of \cite{P1841R2} “Wording for Individually Specializable Numeric Traits”.
\end{wgTitlepage}

\pagestyle{scrheadings}

\addtocounter{section}{-1}
\input{changelog}
\section{Introduction}
\cite{P1841R2} provides wording for numeric traits.
The last design paper was \cite{P0437R1} with additions from \cite{P1370R1}.
Most of the open questions were answered in LEWG already.
The question on \code{reciprocal_overflow_threshold} was deferred to let the authors of \cite{P1370R1} and this paper determine the original intent and its consequences.


\section{Remaining Design Questions}
\begin{enumerate}
  \item Decision already taken in LEWG.

  \item Decision already taken in LEWG.

  \item (no action requested) In the prevision discussion (and poll) of this point we noticed that the traits P2551R0 listed was incomplete/incorrect.
  The poll taken in LEWG therefore said: “The numeric traits that are not meaningful for \code{numeric_limits} (\code{denorm_min}, \code{epsilon}, etc) should be disabled for integral types.”
  The resulting list then is:
  \begin{itemize}
    \item \code{denorm_min}
    \item \code{epsilon}
    \item \code{max_exponent}
    \item \code{max_exponent10}
    \item \code{min_exponent}
    \item \code{min_exponent10}
    \item \code{infinity}
    \item \code{quiet_NaN}
    \item \code{signaling_NaN}
  \end{itemize}
  The (bad) list in P2551R0 was:
  \begin{itemize}
    \item \code{denorm_min}
    \item \code{epsilon}
    \item \code{norm_min}
    \item \code{reciprocal_overflow_threshold}
    \item \code{round_error}
    \item \code{max_exponent}
    \item \code{max_exponent10}
    \item \code{min_exponent}
    \item \code{min_exponent10}
  \end{itemize}

  \item \code{reciprocal_overflow_threshold} is currently defined as:
  \begin{wgText}[{P1841R2 [num.traits.val]}]
\begin{itemdecl}
  template <class T> struct reciprocal_overflow_threshold<T> { @\emph{see below}@ };
\end{itemdecl}
\begin{itemdescr}
\setcounter{Paras}{8}
  \pnum The smallest positive value $x$ of type \type{T} such that \code{T(1)}$/x$ does not overflow.
\end{itemdescr}
  \end{wgText}
  This yields a subnormal number for IEC559 types.
  How should this value change wrt. treat-denormals-as-zero?
  I.e. in a situation where the hardware treats subnormal operands as zero you get 1/0 -> inf, which does overflow.
  In which case it doesn't match the specification anymore.
  This trait is specified by a behavior and as such may depend on processor state.
  As a compile-time constant this value must be independent from runtime behavior.
  But what is the correct value?
  See \url{https://godbolt.org/z/eWxdnTYf8} for a demonstration of the problem.

  Update after consultation with Mark and Damien (the P1370R1 authors):
  \begin{itemize}
  \item It would be possible to decouple the specification from runtime behavior by specifying behavior of constant expressions only;
    i.e. that \code{T(1)}$/x$ does not overflow \emph{in a constant expression}.
  \item P1370R1 presented an algorithm to determine the value and it does not yield the “\emph{smallest} positive value $x$ of type \type{T} such that \code{T(1)}$/x$ does not overflow”.
  \item The P1370R1 algorithm seems to ensure that the value is never subnormal.
    Thus, the specification should have been “The smallest positive \emph{normal} value $x$ of type \type{T} such that \code{T(1)}$/x$ does not overflow”
  \item Since the actual reciprocal overflow threshold depends on runtime state, we're not sure who would/should use a compile-time constant.
    It seems simpler and safer to remove \code{reciprocal_overflow_threshold} from P1841.
    Mark wrote:
    \begin{quote}
    I would prefer to remove \code{reciprocal_overflow_threshold} entirely.  The
    intent of the feature was to describe actual computer behavior at run
    time, so that library authors could write generic code.  However, we
    can't do that with traits.  For example, traits can't change value based
    on compiler flags.  I wish I had realized that better when proposing
    the feature.
    \end{quote}
  \end{itemize}

  \item Decision already taken in LEWG.
\end{enumerate}

\section{Suggested Straw Polls}

\wgPoll{Remove \code{reciprocal_overflow_threshold} from P1841.}{&&&&}

\noindent If the above poll doesn't reach consensus:\\

\wgPoll{Specify the behavior of \code{1 / reciprocal_overflow_threshold} only for constant expressions.}{&&&&}

\wgPoll{Require \code{reciprocal_overflow_threshold} to be a normal number.}{&&&&}

\input{strawpolls}


\end{document}
% vim: sw=2 sts=2 ai et tw=0
