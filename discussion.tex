\section{Discussion}

\subsection{Member Types}
The member types may not seem obvious.
Rationales:
\begin{typelist*}
  \item[value_type]
    In the spirit of the \valuetype member of STL containers, this type denotes the \emph{logical} type of the values in the vector.

  \item[register_value_type]
    On some targets it may be beneficial to implement \datapar instantiations of some \type T with a different type \type{register_value_type}, which has higher precision than \type T.
    This is mostly an implementation detail, but can be important to know in some situations, especially whenever \type{native_handle_type} is involved.

    \guidance{A better name might be \type{native_value_type}.}

  \item[native_handle_type]
    The type used for enabling access to an implementation-defined member object (via the \code{native_handle()} function).

  \item[reference]
    Used as the return type of the non-const scalar subscript operator.
    This may use implementation-defined means to solve possible type aliasing issues.

  \item[const_reference]
    Used as the return type of the const scalar subscript operator.
    From my experience with Vc, it is safest to actually not use a const lvalue reference here, but a temporary.

  \item[mask_type]
    The natural mask type for this \datapar instantiation.
    This type is used as return type of compares and write-mask on assignments.

  \item[size_type]
    Standard member type used for \code{size()} and \code{operator[]}.

  \item[target_type]
    The \type{Abi} template parameter to \datapar.

\end{typelist*}

\subsection{Conversions}
The \datapar conversion constructor only allows implicit conversion from \datapar template instantiations with the same \type{Abi} type and compatible \valuetype.
Discussion in SG1 showed clear preference for only allowing implicit conversion between integral types that only differ in signedness.
All other conversions could be implemented via an explicit conversion constructor.
The alternative (preferred) is to use \simdcast consistently for all other conversions.

\subsection{Broadcast Constructor}
The broadcast constructor is not declared as \code{explicit} to ease the use of scalar prvalues in expressions involving data-parallel operations.
The operations where such a conversion should not be implicit consequently need to use SFINAE / concepts to inhibit the conversion.

\subsection{Fundamental SIMD Type or Not?}
There is a renewed discussion over the question whether \CC{} should define a fundamental, native SIMD type (let us call it \type{fundamental}) and a generic data-parallel type on top which supports an arbitrary number of elements (call it \type{arbitrary}).
The alternative is to only provide the \type{arbitrary}, since it encompasses the \type{fundamental} type.

With regard to this proposal this would add a third template parameter to \datapar and \mask:
\begin{lstlisting}[style=Vc]
template <class T, size_t N = datapar_size_v<T, datapar_target::compatible>,
          class Target = datapar_target::compatible>
class datapar;
\end{lstlisting}

The controversy is about how the flexibility of a type with arbitrary \code N is presented to the users.
Is there a (clear) distinction between a “fundamental” type with target-dependent (i.e. fixed) \code N and a higher-level abstraction with arbitrary \code N which can potentially compile to inefficient machine code.
Or should the \CC{} standard only define \type{arbitrary} and set it to a default \code N value that corresponds to the target-dependent \code N.
Thus, the default \code N, of \type{arbitrary} corresponds to \type{fundamental}.

It is interesting to note that \type{arbitrary<T, 1>} is the class variant of \type T.
Consequently, if we say there is no need for a \type{fundamental} type then we could argue for the deprecation of the builtin arithmetic types, in favor of \type{arbitrary<T, 1>}. \wgNote{This is an academic discussion, of course.}

The author has implemented a library where a clear distinction is made between \type{fundamental<T, Abi>} and \type{arbitrary<T, N>}.
The documentation and all teaching material says that the user should program with \type{fundamental}.
The \type{arbitrary} type should be used in special circumstances, or wherever \type{fundamental} works with the \type{arbitrary} type in its interfaces (e.g. for gather \& scatter or the \code{ldexp} \& \code{frexp} functions).
